<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>Welcome~~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chiayhonl.top/"/>
  <updated>2019-11-13T11:26:15.956Z</updated>
  <id>http://chiayhonl.top/</id>
  
  <author>
    <name>Chiayhon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>努力学习Linux(一)：Linux的前世今生</title>
    <link href="http://chiayhonl.top/2019/11/13/Linux1/"/>
    <id>http://chiayhonl.top/2019/11/13/Linux1/</id>
    <published>2019-11-13T08:52:19.000Z</published>
    <updated>2019-11-13T11:26:15.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本篇将对Linux的历史背景进行相应简单的叙述，仅当做拓展阅读，不感兴趣的读者大可跳过本章节。<br><br></p><a id="more"></a><h2 id="Multics计划"><a href="#Multics计划" class="headerlink" title="Multics计划"></a>Multics计划</h2><p>　　上个世纪六十年代，那个计算机还没有很普及，只有少数人才能使用。<br>　　当时的计算机系统都是批处理的，就是把一批任务一次性提交给计算机，然后就等待结果。并且中途不能和计算机交互。往往准备作业都需要花费很长时间，并且这个时候别人也不能用，导致了计算机资源的浪费。<br>　　为了改变这种情况，在1965年前后，贝尔实验室（Bell）、麻省理工学院（MIT）以及通用电气（GE）联合起来准备研发一个分时多任务处理系统。<br>　　多任务处理系统简单来说就是实现多人同时使用计算机的梦想，并把计算机取名为Multics（多路信息计算系统），但是由于项目太复杂，加上其他原因导致了项目进展缓慢，1969年贝尔实验室觉得这个项目可能不会成功，于是就退出不玩了。<br><br></p><h2 id="Unix的诞生"><a href="#Unix的诞生" class="headerlink" title="Unix的诞生"></a>Unix的诞生</h2><p>　　Bell退出Multics计划之后，Bell实验室的那批科学家就没有什么事做了，其中一个叫做Ken Thompson的人在研发Multics的时候，写了一个叫做太空大战（Space Travel）的游戏，大概就是一个很简单的打打飞机什么的(不是你想的那种)。<br>　　但是呢，这个游戏运行在Multics上的，当Bell退出了Multics项目后，Thompson就没有了Multics的运行环境了。为了能够继续游戏，于是他花了一个月的时间写了一个小型的操作系统，用于运行Space Travel(游戏是工作第一驱动力！)。当完成之后，Thompson怀着激动的心情把身边同事叫过来，让他们来玩他的游戏，大家玩过之后纷纷表示对他的游戏不感兴趣，但是却对他的系统很感兴趣。<br>　　因为MULTICS是“Multiplexed informtion and Computing Service”的缩写（多路信息计算系统），于是他们命名这个系统为：“UNiplexed Information and Computing Service”，缩写为“UNICS”(没路信息计算系统，与Multics相反)。后来大家取其谐音，就称其为“UNIX”了。<br>　　这个时候已经是1970年了，于是就将1970年定为Unix元年，因此计算机上的时间就是从这一年开始计算的。<br>　　后来Unix这个小操作系统就在Bell实验室内部流行开，并经过不断地改良最终在1974年7月Unix发展到第5个版本，Bell实验室公开了Unix，结果引起了学术界的广泛兴趣并对其源码索取。所以，Unix第五个版本就以“仅用于教育目的”的协议，提供给各大学作为教学之用，成为当时操作系统课程的范例教材。各大学公司开始通过Unix源码对Unix进行了各种各样的改进和拓展。　　<br>　　1978年学术界的老大伯克利大学，推出了一份以第六版为基础，加上一些改进和新功能而成的Unix。并命名为BSD（Berkeley Software Distribution伯克利分发版），开创了Unix的另一分支：BSD系列。<br>　　于是乎Unix就有了两个分支，一个就是BSD系列的分支，一个就是Bell本身发放的分支，当时因为Bell属于AT&amp;T，AT&amp;T受到了美国《谢尔曼反托拉斯法》的影响，不能销售除了电话机电报机等之外的商品，后来AT&amp;T分解，Bell可以卖Unix了，Unix走向了商业化，如果想继续使用就需要购买授权，一份授权4万美元。<br><br></p><h2 id="GNU计划"><a href="#GNU计划" class="headerlink" title="GNU计划"></a>GNU计划</h2><p>　　软件产业在70年代成就了两位针锋相对的领袖人物，来自哈佛大学的比尔·盖茨和理查德(Richard M.Stallman)。前者宣布了Copyright(版权)时代的到来，并构建了微软帝国的辉煌；后者于1984年创立自由软件体系GNU，拟定普遍公用版权协议（GeneralPublicLicense，简称GPL），可以说今天Linux的成功就得益于GPL协议。<br>　　理查德被人们誉为自由软件之父，同时他是一个非常“激进”的人。因为Unix商业化的影响，他认为软件是全人类的智慧结晶，不应该为某一家公司服务。在八十年代，他发起了自由软件运动，吹起了共产主义的号角（发起了GNU运动），并发布了软件界的共产主义宣言（GPL协议），并且这一运动得到了很多人的认同。<br>　　所谓自由软件自由就是指：自由使用、自由学习和修改、自由分发、自由创建衍生版。<br>　　GNU的定义是一个递归缩写，就是GNU IS NOT UNIX。就是说Unix是流氓，我不是。有意思的是，GNU运动是1984年开始的，而那个时候Linux系统还没有诞生呢，所以Stallman宝宝心里苦啊，就在大家逐渐失去信心的时候，1991年Linus Torvalds带着他的Linux闪亮登场了，给GNU运动画了一个完美的句号。<br><br></p><h2 id="Minix的诞生"><a href="#Minix的诞生" class="headerlink" title="Minix的诞生"></a>Minix的诞生</h2><p>　　在1981 年，IBM 公司推出了享誉全球的微型计算机IBM PC。在1981-1991 年间，MS-DOS 操作系统 一直是微型计算机操作系统的主宰。此时计算机硬件价格虽然逐年下降，但软件价格仍然居高不下 。<br>　　当时Apple 的MACs 操作系统可以说是性能最好的，但是其天价使得没人能够轻易靠近。<br>　　另一个计算机技术阵营就是UNIX 世界。但是UNIX 操作系统就不仅是价格昂贵的问题 了。为了寻求高利润率，UNIX 经销商们把价格抬得极高，PC 小用户根本不能靠近它。曾经一度收到Bell Labs许可而能在大学中用于教学的UNIX 源代码也一直被小心地守卫着不许公开。<br>　　对于广大的PC 用户，软件行业的大型供应商们始终没有给出有效的解决这个问题的手段。<br>　　而在Unix昂贵的授权费用下，很多大学不得不停止对其研究，老师导致上课也不知道讲什么了。于是终于在1987年荷兰有个大学教授安德魯(Andrew S. Tanenbaum 简称AST)写了一个Minix，类似于Unix，主要用于学生学习操作系统原理。<br>　　在MINIX 操作系统的出现的同时，一本描述其设计实现原理的书与其同时发行。由于AST的这本书写的非常详细，并且叙述得有条有理，于是几乎全世界的计算机爱好者都开始看这本书，以期能理解操作系统的工作原理。<br>　　当Minix流传开来之后，世界各地的黑客们纷纷开始使用并改进，希望把改进的东西合并到Minix中，但是安德鲁觉得他的系统是用于教学的，不能破坏纯净性，于是拒绝了。<br>　　虽然作为一个操作系统，Minix 并不是优秀者，但它最大的意义在于提供了用C 语言和汇编语言编写的系统源代码。这是第一次使得有抱负的程序员或hacker 能够阅读操作系统的源代码。在当时，这种源代码可是软件商们一直小心守护着的秘密。<br><br></p><h2 id="Linux的诞生"><a href="#Linux的诞生" class="headerlink" title="Linux的诞生"></a>Linux的诞生</h2><p>　　MINIX 操作系统流传引来了一大批计算机爱好者，  其中也包括Linux 系统的创始者林纳斯.托瓦兹(Linus Benedict Torvalds)。当时(1991 年)，Linus是赫尔辛基大学计算机科学系的二年级学生，也是一个自学的计算机hacker。这个21岁的芬兰年轻人喜欢鼓捣他的计算机，测试计算机的性能和限制。但当时他所缺乏的就是一个专业级的操作系统。<br>　　在同一年间，GNU 计划已经开发出了许多工具软件。其中最受期盼的GNU C 编译器已经出现，但还没有开发出免费的GNU 操作系统。 即使是教学使用的MINIX 操作系统也开始有了版权，需要购买才能得到源代码。虽然GNU 的操作系统HURD一直在开发之中，但在当时看来不能在几年内完成。<br>　　为了能更好地学习计算机知识（或许也只是为了兴趣），Linus 使用圣诞节的压岁钱和贷款购买了一台386 兼容电脑 ，并从美国邮购了一套MINIX 系统软件 。就在等待MINIX 软件期间，Linus 认真学习了有关Intel 80386 的硬件知识。为了能通过Modem 拨号连接到学校的主机上，他使用汇编语言并利用80386 CPU的多任务特性编制出一个终端仿真程序。此后为了将自己一台老式电脑上的软件复制到新电脑上，他还为软盘驱动器、键盘等硬件设备编制出相应的驱动程序（他编写了一些os相关的程序）。<br>　　通过编程实践，并在学习过程中认识到MINIX 系统的诸多限制（MINIX 虽然很好，但只是一个用于教学目的简单操作系统，而不是一个强有力的实用操作系统），而且通过上述实践Linus 已经有了一些类似于操作系统硬件设备驱动程序的代码，于是他开始有了编制一个新操作系统的想法。（一个影响深远的想法诞生了）。<br>　　从1991 年4 月 份开始，Linus 几乎花费了全部时间研究MINIX-386 系统(Hacking the kernel)，并且尝试着移植GNU 的软件到该系统上(GNU gcc、bash、gdb 等)。并于4 月13 日在comp.os.minix 上发布说自己已经成功地将bash 移植到了MINIX 上，而且已经爱不释手、不能离开这个shell 软件了。<br>　　在1991年9月17日，Linus在互联网上公布了自己写的Linux，可能是表达对安德鲁的不满吧（为什么不接受大家的好意呢？你让大家的满腔热情往哪放呢？），于是Linus发布了一个帖子，大概就是说：我写了一个操作系统的内核，但是还不够完善，你们以任何姿势使用不收费，也可以帮助我一起修改。帖子发出后引起了强烈的反响。在大家的努力下，于1994年Linux的1.0版本正式发布。<br>　　Linux为什么会引起如此强烈的反响呢？因为Unix有版权，爱好编程的狂热分子在研究Unix的时候很容易吃上官司 ，而Linux是遵循GPL协议的，可以免费使用，让黑客们尽情的施展（这里的黑客指那些技术大牛，不是指那些利用计算机干坏事的人）。于是Linux提供内核（kernel），GNU提供外围软件，就这样GNU/Linux诞生了。<br>　　所以，看到这里你就会了解到Unix是1970年出现的，Linux是1991年发布的，但Linux是不同于Unix的操作系统。<br><br></p><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>　　上面主要介绍了Linux以及Unix的一些历史故事，下面则介绍操作系统方面的知识。在进入正题之前，我们先简单了解一下操作系统。<br>　　我们都知道，CPU是由运算器和控制器组成的，程序在运行的时候就是调用CPU的指令进行一些运算操作，例如加减乘除。CPU能够调用的指令集合，就是指令集。但是不幸的是CPU的生产厂家不止一家，例如Intel、AMD等。即便是同一家厂商生产CPU，不同平台之间的指令集也不一样。那么程序员在编写程序的时候会遇到一个尴尬的局面，就是当你在某一个平台编码的时候，如果想将程序移到另外一个平台上，就需要重新编码，重新编码还不是最可怕的，可怕的是你得学习对应的新平台的指令集。<br>　　一般而言，我们称直接在硬件层面上进行编程是硬件规格层的编程（hardware spaceifiacation），例如调用CPU提供的指令等。你需要知道的是，不同硬件提供的API是个不相同的。如果程序员要编程还得精通硬件那得多难，所以我们需要一个<strong>通用软件</strong>来<strong>提供统一接口，以屏蔽硬件的差异化</strong>。这个通用软件就是操作系统。<br>　　操作系统将底层硬件提供的接口进行封装，程序员直接调用由操作系统提供的接口，也称为<strong>系统调用</strong>。但是系统封装的接口会很多吗？显然不会很多，因为如果操作系统提过几万个接口，程序员还不累的学出血。<br>　　一般而言，系统提供的接口都是短小精悍，我们需要像搭积木一样，将其组装起来提供更为丰富的功能，并且将组装好的代码做成库，供别人使用。这样一来，就是<strong>库调用</strong>。在Windows上库一般都是dll（Dynamic Link Library），而在Linux或者Unix上我们一般称之为so（shared object），就是共享的代码，大家都可以调用。<br>　　现在我们知道了，操作系统的一个<strong>重要功能</strong>就是<strong>将硬件提供的功能进行封装，我们调用操作系统提供的接口就是系统调用（system call）。然后将系统提供的接口组合后形成更丰富的库</strong>。当然操作系统还有其他的功能，例如CPU的时间分片、安全保证等。<br><br></p><h2 id="Linux的发行版本"><a href="#Linux的发行版本" class="headerlink" title="Linux的发行版本"></a>Linux的发行版本</h2><p>　　我们知道Linux或者Unix是一个操作系统，1991年的Linus Torvalds公布的是Linux的内核（kernel）。但是要注意的是，公布的是源码，并不是编译好的直接可安装的操作系统，我们如何安装一个操作系统呢？很简单啊，就是先下载一份源码，然后进行编译安装，但是编译的时候程序需要运行在操作系统上啊，操作系统呢？还没有编译呢。于是就陷入了一个死循环中，就是我们要安装操作系统，就需要编译，编译的时候需要操作系统，这样就是鸡生蛋，蛋生鸡。<br>　　这里就需要引入<strong>交叉编译</strong>了，具体做法是假设我们要在电脑上安装Linux，我们把A的硬盘拆下来，放到已经安装了操作系统的电脑B上，然后编译，将编译好的操作系统放到硬盘上，再把硬盘装回去，开机启动，这就是交叉编译安装系统。<br>　　这得有多难啊，入门难度实在太高了，所以我们迫切需要一种简单的方式来安装。于是就出现了这么一种公司，他们将已经公开好的Kernel（内核）再加上一些开源的周边软件收集起来编译成二级制文件放到网上供别人使用，其中<strong>Red Hat</strong>（红帽）就是其中著名的一家。<br>　　我们知道Linux是遵循GPL协议的，也就是公开免费的，那么他们怎么盈利呢？既然不能卖软件，那么就卖服务呗，比如说，发现了Linux漏洞，然后Red Hat修复，如果你买了我们的服务，我们就将补丁程序给你，并指导你安装，所有问题都帮你解决。<br>　　世界上总是不缺好事者，RedHat既然可以这么做，为什么就不能有好心人免费做呢？是的，有这样一个社区，他们把RedHat的源码拿过来，然后编译成操作系统放出去，这就是<strong>CentOS</strong>，就是社区版的RedHat，所以基本RedHat的补丁包出来一个月之后，CentOS就出现对应的补丁包了。这对于Red Hat是好事还是坏事呢？这恐怕只有当事人知道了，不过在2014年年初传来消息，RedHat收编了CentOS的团队。就像MSDN I TELL YOU 上面都是微软的正版软件，可以随便下载，但是这不也是为微软做了免费宣传吗。<br>　　当别人说Linux的版本时，一般来说有两个版本，一个是内核的版本，一个是发行的版本。例如登录到终端执行命令<br><br></p><h2 id="Linux的哲学思想"><a href="#Linux的哲学思想" class="headerlink" title="Linux的哲学思想"></a>Linux的哲学思想</h2><p>　　&lt;1&gt;一切皆文件，把几乎所有的资源都组织成文件的格式，我们只需要一个文本编辑工具，就可以修改工作的特性了，很方便。<br>　　&lt;2&gt;组合小程序，完成复杂任务，例如将系统调用组合形成库（在Linux就是so结尾的文件）。<br>　　&lt;3&gt;尽量避免和用户交互，Windows上就是弹框，让你点确定。在Linux上，如果执行一个程序之后没有任何提示，那就是最后的提示。<br>　　&lt;4&gt;使用纯文本文件保存配置信息，这个在第一点就可以看出来。<br><br></p><p>参考资料：<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5b250ZS9hcnRpY2xlL2RldGFpbHMvNjA3NjAwMw==" title="https://blog.csdn.net/lyonte/article/details/6076003">https://blog.csdn.net/lyonte/article/details/6076003<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTIzNTkzL2FydGljbGUvZGV0YWlscy82MzY4Mzg1Ng==" title="https://blog.csdn.net/qq_35523593/article/details/63683856">https://blog.csdn.net/qq_35523593/article/details/63683856<i class="fa fa-external-link"></i></span></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本篇将对Linux的历史背景进行相应简单的叙述，仅当做拓展阅读，不感兴趣的读者大可跳过本章节。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://chiayhonl.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://chiayhonl.top/tags/Linux/"/>
    
      <category term="简介" scheme="http://chiayhonl.top/tags/%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——《高性能MySQL》</title>
    <link href="http://chiayhonl.top/2019/11/12/booknote1/"/>
    <id>http://chiayhonl.top/2019/11/12/booknote1/</id>
    <published>2019-11-12T05:10:31.000Z</published>
    <updated>2019-11-13T09:07:31.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/spoiler.css&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;/js/spoiler.js&quot; type=&quot;text/javascript&quot; async&gt;&lt;/script&gt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://chiayhonl.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="http://chiayhonl.top/tags/MySQL/"/>
    
      <category term="读书笔记" scheme="http://chiayhonl.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(更新中)</title>
    <link href="http://chiayhonl.top/2019/11/12/%E5%89%91%E6%8C%87offer/"/>
    <id>http://chiayhonl.top/2019/11/12/%E5%89%91%E6%8C%87offer/</id>
    <published>2019-11-12T00:13:20.000Z</published>
    <updated>2019-11-14T15:28:23.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本文将对剑指offer的题型进行整理，包括解题思路和代码实现。分类依据则是基于题目的侧重考点进行分类。</p><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><em>反转链表</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzc1ZTg3OGRmNDdmMjRmZGM5ZGMzZTQwMGVjNjA1OGNhP3RwSWQ9MTMmdHFJZD0xMTE2OCZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_24<i class="fa fa-external-link"></i></span></p><p><strong>题目描述</strong></p><p><img src="%E5%89%91%E6%8C%87offer_24.jpg" alt="图片加载失败"></p><p><strong>解题思路</strong></p><p>　　反转链表链表大体思路就是将链表中的各个结点的<code>next</code>指针指向前一个，实现链表反转。   </p><p>　　递归版本思路：将当前结点后面的链表进行反转，然后将当前结点作为反转后链表的后继结点。<br>　　非递归版本思路：用两个变量记录当前结点的前驱和后继结点，前者用来反转当前结点的指向，后者用来记录下一个要反转的结点  </p><p><strong>代码实现</strong>  </p><p>　　递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果传入的头结点为空，返回null</span></span><br><span class="line">           <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)    <span class="keyword">return</span> head; <span class="comment">//如果传入的头结点下一结点指向为null，说明链表长度为1或者已经到链表尾部，返回自身</span></span><br><span class="line">           ListNode newHead = ReverseList(head.next);<span class="comment">//反转当前结点后的链表，并返回反转后的新表头</span></span><br><span class="line">           head.next.next = head;<span class="comment">//将当前结点下一结点的next指针指向自己，即将当前结点接入反转后链表，</span></span><br><span class="line">           head.next = <span class="keyword">null</span>;<span class="comment">//将当前结点的next指针指向空，完成反转</span></span><br><span class="line">           <span class="keyword">return</span> newHead;<span class="comment">//返回反转后的新表头</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　非递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果传入的头结点为空，返回null</span></span><br><span class="line">           ListNode pre = <span class="keyword">null</span>;<span class="comment">//定义当前结点的前驱结点</span></span><br><span class="line">           ListNode next = <span class="keyword">null</span>;<span class="comment">//定义当前结点的后继结点</span></span><br><span class="line">           <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;<span class="comment">//进行反转操作，当当前结点为空时跳出循环，即所有结点都以反转完毕</span></span><br><span class="line">               next = head.next;<span class="comment">//传入当前结点的后继结点</span></span><br><span class="line">               head.next = pre;<span class="comment">//进行反转，当前结点指向前驱结点</span></span><br><span class="line">               pre = head;<span class="comment">//反转完成，准备下一次反转，前驱结点和当前结点都向后移动</span></span><br><span class="line">               head = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pre;<span class="comment">//当前结点为空时，前驱结点在链表尾部指向新表头</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　非递归优化：实例化用一个临时结点，使其<code>next</code>指针指向当前结点的前驱结点，避免当前结点为空的判断，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//实例化临时结点</span></span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = temp.next;</span><br><span class="line">            temp.next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.next;<span class="comment">////当前结点为空时，前驱结点在链表尾部指向新表头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><em>从尾到头打印链表</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2QwMjY3ZjdmNTViMzQxMmJhOTNiZDM1Y2ZhOGU4MDM1P3RwSWQ9MTMmdHFJZD0xMTE1NiZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_6<i class="fa fa-external-link"></i></span>  </p><p><strong>问题描述</strong>  </p><p><img src="%E5%89%91%E6%8C%87offer_6.jpg" alt="图片加载失败"></p><p><strong>解题思路</strong>  </p><p>　　思路推荐：  </p><p>　　头插法：利用ArrayList集合的<strong>add(int index , E element)方法</strong>，逐个将结点从集合头部插入。</p><p>　　递归思路：将传入结点后面的链表反转并加入ArrayList集合，最后将传入结点加入到ArrayList集合末尾。  </p><p>　　利用Collections类：通过调用Collections里的<strong>reverse方法</strong>即可实现反转。  </p><p>　　利用栈：利用栈的<strong>先进后出</strong>特性实现链表反转输出<br><br><br>　　不推荐：  </p><p>　　自实现：借用上题自实现的反转方法，反转后加入ArrayList集合中</p><p><strong>代码实现</strong>  </p><p>　　递归思路(T(N)=O(N),S(N)=O(1))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(listNode.next!=<span class="keyword">null</span>)&#123;<span class="comment">//如果当前结点及它的下一结点都不为空，先从尾到头把它后面的链表加入ArrayList集合</span></span><br><span class="line">                   list=printListFromTailToHead(listNode.next);</span><br><span class="line">               &#125;</span><br><span class="line">               list.add(listNode.val);<span class="comment">//将当前结点加入ArrayList集合</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> list;<span class="comment">//返回ArrayList集合</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　头插法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//先将所有结点的值按顺序加入ArrayList集合</span></span><br><span class="line">            list.add(<span class="number">0</span> , listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　利用Collections类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//先将所有结点的值按顺序加入ArrayList集合</span></span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Collections.reverse(list);<span class="comment">//使用Collections的reverse方法，直接将list反转</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　利用栈:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">import</span> java.util.Stack;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//所有结点入栈</span></span><br><span class="line">               s.push(listNode.val);</span><br><span class="line">               listNode = listNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(!s.isEmpty())&#123;<span class="comment">//所有结点出栈，并加入ArrayList集合</span></span><br><span class="line">               list.add(s.pop());</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　自实现：</p><div class="spoiler collapsed"><div class="spoiler-title">自实现</div><div class="spoiler-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建ArrayList集合</span></span><br><span class="line">           <span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//如果插入结点不为空执行方法，否则直接返回</span></span><br><span class="line">               ListNode newHead = <span class="keyword">this</span>.reverse(listNode);<span class="comment">//调用反转方法返回反转后的新表头</span></span><br><span class="line">               <span class="keyword">while</span>(newHead != <span class="keyword">null</span>)&#123;<span class="comment">//将反转后的链表逐个加入ArrayList集合</span></span><br><span class="line">                   list.add(newHead.val);</span><br><span class="line">                   newHead = newHead.next;</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           <span class="keyword">return</span> list;<span class="comment">//返回ArrayList集合</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//反转方法源自上面一题的非递归方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">           ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">           ListNode next = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">               next = listNode.next;</span><br><span class="line">               listNode.next = node.next;</span><br><span class="line">               node.next = listNode;</span><br><span class="line">               listNode = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> node.next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></div><br><h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a><em>链表中倒数第k个结点</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzUyOWQzYWU1YTQwNzQ5Mjk5NGFkMmEyNDY1MTgxNDhhP3RwSWQ9MTMmdHFJZD0xMTE2NyZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_22<i class="fa fa-external-link"></i></span>  </p><p><strong>题目描述</strong><br><img src="%E5%89%91%E6%8C%87offer_22.jpg" alt="图片加载失败">  </p><p><strong>解题思路</strong><br>　　分析：链表不像数组能通过索引直接确定位置，所以难点在于对于一个结点，该如何明确它是倒数第几个。<br>　　思路：维护两个指针，,第一个指针先走k-1步，第二个指针保持不动；从第k步开始，两个指针一起向后移动。当走在前面的指针移动到链表末尾时，后面指针所指向的结点即为目标结点。<br><img src="%E5%89%91%E6%8C%87offer_22.1.jpg" alt="图片加载失败"><br>　　此外还可以用<br>　　　　A. 利用ArrayList集合的索引实现。<br>　　　　B. 利用栈实现;<br>　　只不过这两种方法空间复杂度会比较高，所以不推荐。 </p><p><strong>代码实现</strong><br>　　双指针(T(N)=O(N),S(N)=O(1))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           ListNode target , pAhead;<span class="comment">//维护两个指针</span></span><br><span class="line">           target = pAhead = head;<span class="comment">//双双指向链表开头</span></span><br><span class="line">           <span class="keyword">int</span> counter = <span class="number">0</span>;<span class="comment">//用来记录pAhead移动步数</span></span><br><span class="line">           <span class="keyword">for</span>(;pAhead != <span class="keyword">null</span>; counter++)&#123;<span class="comment">//pAhead指针开始移动到链表尾部</span></span><br><span class="line">               <span class="keyword">if</span>(counter &gt;= k)&#123;<span class="comment">//如果pAhead指针已经移动了k步，则target开始移动</span></span><br><span class="line">                   target = target.next;</span><br><span class="line">               &#125;</span><br><span class="line">               pAhead = pAhead.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//移动步数counter遍历完成时是等于链表长度的，如果移动步数小于k，说明k超过链表长度</span></span><br><span class="line">           <span class="keyword">return</span> counter &lt; k? <span class="keyword">null</span>: target;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　集合法(T(N)=O(N),S(N)=O(N))：将所有结点加入ArrayList集合，倒数第k个即为正数第n-k+1个(n为结点数),利用get方法即可求出</p><div class="spoiler collapsed"><div class="spoiler-title">集合法</div><div class="spoiler-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;<span class="comment">//结点全加入集合里</span></span><br><span class="line">               list.add(head);</span><br><span class="line">               head = head.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(k &gt; list.size() || k &lt;= <span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//k大于结点数或者为非正数，返回null</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">return</span> list.get(list.size() - k);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></div><p>　　栈方法(T(N)=O(N),S(N)=O(N))：利用栈的先进后出，先将所有结点加入栈，最后再从栈弹出k个元素，弹出的第k个即为倒数第k个</p><div class="spoiler collapsed"><div class="spoiler-title">栈方法</div><div class="spoiler-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;<span class="comment">//所有结点入栈</span></span><br><span class="line">               stack.push(head);</span><br><span class="line">               head = head.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(k &gt; stack.size() || k &lt;= <span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//k大于结点数或者为非正数，返回null</span></span><br><span class="line">           <span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;<span class="comment">//先弹出k-1个元素</span></span><br><span class="line">               stack.pop();</span><br><span class="line">               k--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> stack.pop();<span class="comment">//返回倒数第k个</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></div><br><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><em>合并两个排序的链表</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2Q4YjZiNDM1OGY3NzQyOTRhODlkZTJhNmFjNGQ5MzM3P3RwSWQ9MTMmdHFJZD0xMTE2OSZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_25<i class="fa fa-external-link"></i></span></p><p>　　<strong>题目描述</strong><br><img src="%E5%89%91%E6%8C%87offer_25.jpg" alt="图片加载失败"> </p><p>　　<strong>解题思路</strong><br>　　递归思路:当两个结点中，有一个为空，返回不为空的结点。都不为空时，继续将较小结点的后一结点和较大结点进行合并，直到其中一方为空。<br>　　非递归思路:当两个结点中，有一个为空，返回不为空的结点。都不为空时,设立一个头结点,每次比较将两个结点较小的接入头结点后面，直到一方为空。  </p><p>　　<strong>代码实现</strong><br>　　递归思路：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)<span class="comment">//如果有一个结点为空，就返回另一个结点 </span></span><br><span class="line">               <span class="keyword">return</span> list1 == <span class="keyword">null</span>? list2 : list1;</span><br><span class="line">           <span class="keyword">if</span>(list1.val &gt; list2.val)&#123;<span class="comment">//list2较小时</span></span><br><span class="line">               list2.next = Merge(list1, list2.next);<span class="comment">//将以list1和list2下一结点开头的两个链表进行合并，并接入到list2后面。</span></span><br><span class="line">               <span class="keyword">return</span> list2;<span class="comment">//返回合并后的链表list2</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则，list1较小时</span></span><br><span class="line">               list1.next = Merge(list1.next, list2);<span class="comment">//将以list2和list1下一结点开头的两个链表进行合并，并接入到list1后面。</span></span><br><span class="line">               <span class="keyword">return</span> list1;<span class="comment">//返回合并后的链表list1</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　非递归:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)<span class="comment">//如果有一个结点为空，就返回另一个结点 </span></span><br><span class="line">               <span class="keyword">return</span> list1 == <span class="keyword">null</span>? list2 : list1;</span><br><span class="line"></span><br><span class="line">           ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//先设一个头结点作为当前结点</span></span><br><span class="line">           ListNode curNode = head;<span class="comment">//设置当前结点指针</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;&amp;list2!=<span class="keyword">null</span>)&#123;<span class="comment">//当有一个结点为空时跳出循环</span></span><br><span class="line">               <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;<span class="comment">//list1较小时</span></span><br><span class="line">          curNode.next = list1;<span class="comment">//将list1接入head链表后</span></span><br><span class="line">           curNode = curNode.next;<span class="comment">//当前结点向后移动</span></span><br><span class="line">           list1 = list1.next;<span class="comment">//较小结点list1向后移动</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//list2较小时</span></span><br><span class="line">           curNode.next = list2;<span class="comment">//将list2接入head链表后</span></span><br><span class="line">           curNode = curNode.next;<span class="comment">//当前结点向后移动</span></span><br><span class="line">           list2 = list2.next;<span class="comment">//较小结点list1向后移动</span></span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//把未结束的链表连接到合并后的链表尾部</span></span><br><span class="line">           <span class="keyword">if</span>(list1!=<span class="keyword">null</span>)&#123;<span class="comment">//若是list1不为空就把list1接入链表尾部</span></span><br><span class="line">           curNode.next=list1;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(list2!=<span class="keyword">null</span>)&#123;<span class="comment">//若是list2不为空就把list2接入链表尾部</span></span><br><span class="line">           curNode.next=list2;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> head.next;<span class="comment">//返回合并后链表的第一个结点</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a><em>两个链表的第一个公共结点</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzZhYjFkOWEyOWU4ODQ1MDY4NTA5OWQ0NWM5ZTMxZTQ2P3RwSWQ9MTMmdHFJZD0xMTE4OSZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_52<i class="fa fa-external-link"></i></span></p><p><strong>题目描述</strong><br><img src="%E5%89%91%E6%8C%87offer_52.jpg" alt="图片加载失败">  </p><p><strong>解题思路</strong><br>　　对于上图。我们设链表1的长度为 a + c，链表2的长度为 b + c，其中c为尾部公共部分长度<br>　　思路有以下几种：<br>　　A:利用哈希表:先将一个链表加入哈希表，在遍历另一个链表时判断哈希表中有无对应的key，即可求得第一个公共结点<br>　　B:利用长度差：求出两个链表长度差值即b-a，再让位于较长的链表的结点指针先走b-a步，再让另一个出发，之后每走一步两者就进行比较一次，若是相等，指向的则为第一个公共结点<br>　　C:利用双指针循环遍历：当访问链表 A 的指针访问到链表尾部时，令它从链表B的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。  </p><p><strong>代码实现</strong></p><p>　　哈希表：此方法实现逻辑简单，但是数据量庞大时效率不如方法B，空间复杂度也比其他方法高，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">           HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//建立HashSet集合</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(pHead1 != <span class="keyword">null</span>)&#123;<span class="comment">//将链表1的结点加入哈希表</span></span><br><span class="line">               set.add(pHead1);</span><br><span class="line">               pHead1 = pHead1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(pHead2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(set.contains(pHead2))&#123;<span class="comment">//判断当前链表2的结点在哈希表是否存在</span></span><br><span class="line">                   <span class="keyword">return</span> pHead2;<span class="comment">//存在则说明是公共结点</span></span><br><span class="line">               &#125;</span><br><span class="line">               pHead2 = pHead2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//哈希表没有存储pHead2的结点,返回空</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　双指针循环遍历：双指针循环遍历相当于是两个指针同时出发直到它们在同一结点相遇，此结点即为第一个公共结点。此方法代码量简短，但是如果没有公共结点时会陷入死循环。此方法在数据量庞大时效率极为低效，基本不考虑使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = pHead1 , node2 = pHead2;<span class="comment">//定义两个用来遍历链表的指针node1，node2</span></span><br><span class="line">         <span class="keyword">while</span>(node1 != node2)&#123;<span class="comment">//当两指针指向的结点相等时才跳出循环</span></span><br><span class="line">             node1 = node1 == <span class="keyword">null</span>? pHead1 : node1.next;<span class="comment">//否则若node1到达链表末尾时，重新出发进行遍历</span></span><br><span class="line">             node2 = node2 == <span class="keyword">null</span>? pHead2 : node2.next;<span class="comment">//若node2到达链表末尾时，也重新出发进行遍历</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;<span class="comment">//跳出循环时的node1和node2指向第一个公共结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　利用长度差：利用长度差来实现同时到达公共结点，此方法适用于庞大数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">           ListNode current1 = pHead1;<span class="comment">// 链表1</span></span><br><span class="line">           ListNode current2 = pHead2;<span class="comment">// 链表2</span></span><br><span class="line">           <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> length1 = getLength(current1);</span><br><span class="line">           <span class="keyword">int</span> length2 = getLength(current2);</span><br><span class="line">           <span class="comment">// 两连表的长度差</span></span><br><span class="line">            </span><br><span class="line">           <span class="comment">// 如果链表1的长度大于链表2的长度</span></span><br><span class="line">           <span class="keyword">if</span> (length1 &gt;= length2) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = length1 - length2;</span><br><span class="line">               <span class="comment">// 先遍历链表1，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   current1 = current1.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果链表2的长度大于链表1的长度</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (length1 &lt; length2) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = length2 - length1;</span><br><span class="line">               <span class="comment">// 先遍历链表1，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   current2 = current2.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//开始齐头并进，直到找到第一个公共结点</span></span><br><span class="line">           <span class="keyword">while</span>(current1!=current2)&#123;</span><br><span class="line">               current1=current1.next;</span><br><span class="line">               current2=current2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> current1;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 求指定链表的长度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">           ListNode current = pHead;</span><br><span class="line">           <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">               length++;</span><br><span class="line">               current = current.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> length;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　优化：长度相同且有公共结点，第一次就会遍历就能判断出来，不必执行接下来的操作可以直接返回。长度不相同则记录两个链表长度，再执行接下来操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> length1 = <span class="number">0</span>, length2 = <span class="number">0</span>;</span><br><span class="line">           ListNode node1 = pHead1 , node2 = pHead2;<span class="comment">//定义两个用来遍历链表的指针node1，node2</span></span><br><span class="line">           <span class="keyword">while</span>(node1 != node2 &amp;&amp; (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>))&#123;<span class="comment">//当两指针都为null时才结束循环</span></span><br><span class="line">   </span><br><span class="line">               <span class="keyword">if</span>(node1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   node1 = node1.next;</span><br><span class="line">                   length1++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   node2 = node2.next;</span><br><span class="line">                   length2++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node1 == node2 &amp;&amp; (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>))   </span><br><span class="line">                   <span class="keyword">return</span> node1;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 两连表的长度差</span></span><br><span class="line">           <span class="keyword">if</span> (length1 &gt; length2) &#123;<span class="comment">// 如果链表1的长度大于链表2的长度</span></span><br><span class="line">               <span class="keyword">int</span> len = length1 - length2;</span><br><span class="line">               <span class="comment">// 先遍历链表1，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   pHead1 = pHead1.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (length1 &lt; length2) &#123;<span class="comment">// 如果链表2的长度大于链表1的长度</span></span><br><span class="line">               <span class="keyword">int</span> len = length2 - length1;</span><br><span class="line">               <span class="comment">// 先遍历链表2，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   pHead2 = pHead2.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//开始齐头并进，直到找到第一个公共结点</span></span><br><span class="line">           <span class="keyword">while</span>(pHead1!=pHead2)&#123;</span><br><span class="line">               pHead1=pHead1.next;</span><br><span class="line">               pHead2=pHead2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pHead1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h2 id="递归与循环"><a href="#递归与循环" class="headerlink" title="递归与循环"></a>递归与循环</h2><h2 id="查找与排序"><a href="#查找与排序" class="headerlink" title="查找与排序"></a>查找与排序</h2><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="动态规划与贪心算法"><a href="#动态规划与贪心算法" class="headerlink" title="动态规划与贪心算法"></a>动态规划与贪心算法</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文将对剑指offer的题型进行整理，包括解题思路和代码实现。分类依据则是基于题目的侧重考点进行分类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://chiayhonl.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chiayhonl.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo框架(二)：博客主题的美化</title>
    <link href="http://chiayhonl.top/2019/11/11/Hexo-Config/"/>
    <id>http://chiayhonl.top/2019/11/11/Hexo-Config/</id>
    <published>2019-11-11T10:29:08.000Z</published>
    <updated>2019-11-13T15:14:01.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h2><p>在我们搭建好自己的博客后，如果你不急的话第一件事并不是开始写博客，而是对博客的外形进行包装和美化。这里主要介绍博客主题的选择与美化。</p><a id="more"></a><br><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a><em>主题选择</em></h2><p>Hexo默认的主题是landscape，这里只推荐我用过的主题：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0" title="https://github.com/theme-next/hexo-theme-next">Next<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdHRlbi9oZXhvLXRoZW1lLXlpbGlh" title="https://github.com/litten/hexo-theme-yilia">Yilia<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JsaW5rZm94L2hleG8tdGhlbWUtbWF0ZXJ5" title="https://github.com/blinkfox/hexo-theme-matery">matery<i class="fa fa-external-link"></i></span></p></li></ul><p>如果不满意可以自行去<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=" title="https://hexo.io/themes/">Themes<i class="fa fa-external-link"></i></span>商店选择，这里仅针对本博客用的Next主题进行配置。不同的主题大体配置相同，根据官方文档指引即可自行配置。</p>   <br><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a><em>主题下载</em></h2><ol><li><p>下载主题</p><p>进入你的博客文件夹(Hexo),打开Git Bash输入以下命令，等待下载完成。</p><p>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0LmdpdA==" title="https://github.com/theme-next/hexo-theme-next.git">https://github.com/theme-next/hexo-theme-next.git<i class="fa fa-external-link"></i></span> themes/next</p></li><li><p>配置主题</p><p>下载完成后，在themes目录下会有next文件夹，这就是我们要的next主题。然后在主目录下找到站点配置文件_config.yml 中的theme字段，更改为主题文件夹的名称：</p><p> theme: landscape –&gt; theme: next</p></li></ol><br><h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a><em>主题优化</em></h2><p>   主题一般都有比较详细的说明文档，若想自行配置的也可参考<span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20vdGhlbWUtc2V0dGluZ3MuaHRtbA==" title="http://theme-next.iissnan.com/theme-settings.html">next官方文档<i class="fa fa-external-link"></i></span>。</p><p>   这里大致进行一些简单的美化：</p><ul><li><p>配置博客基本信息</p></li><li><p>设置主题语言</p></li><li><p>设置动态背景</p></li><li><p>上传头像,并设置头像旋转效果</p></li><li><p>设置个人社交图标链接</p></li><li><p>设置RSS</p></li><li><p>设置看板娘</p></li><li><p>代码折叠功能</p></li></ul><h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><p>　　安装spoiler插件:</p><pre><code>`npm install hexo-sliding-spoiler --save`</code></pre><p>　　折叠语法：</p><pre><code>{% spoiler 标题 %}...内容...{% endspoiler %}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;em&gt;前言&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;在我们搭建好自己的博客后，如果你不急的话第一件事并不是开始写博客，而是对博客的外形进行包装和美化。这里主要介绍博客主题的选择与美化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo框架(一):个人博客的搭建</title>
    <link href="http://chiayhonl.top/2019/11/10/Hexo_build/"/>
    <id>http://chiayhonl.top/2019/11/10/Hexo_build/</id>
    <published>2019-11-10T12:00:00.000Z</published>
    <updated>2019-11-13T11:47:51.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　搭博客需要一个理由.关于为什么要自己搭建一个博客,我想是在看到别人清晰有条理的布局与归类后,为了改善自己归纳整理的能力,于是决定自己搭一个(其实更多是冲着看板娘去的).捣鼓了一个下午之后,终于搞清楚一点门路.就以此记录一点心得吧<br><br></p><a id="more"></a><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><p>　　搭建个人博客=域名(外网可访问的地址)+外网服务器(外网存储文件图片的地方)+解析(本地与服务器做映射)</p><p>　　搭建流程大概分为:</p><p>　　1. 下载<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0LXNjbS5jb20vZG93bmxvYWQv" title="https://www.git-scm.com/download/">git<i class="fa fa-external-link"></i></span>,下载<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL2N1cnJlbnQv" title="https://nodejs.org/en/download/current/">node.js<i class="fa fa-external-link"></i></span>,搭建<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv" title="https://hexo.io/zh-cn/docs/">Hexo<i class="fa fa-external-link"></i></span></p><p>　　2. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">GitHub<i class="fa fa-external-link"></i></span>仓库注册与部署</p><p>　　3. 域名购买与绑定</p><p>　　4. 域名解析</p><h3 id="环境的下载与安装"><a href="#环境的下载与安装" class="headerlink" title="环境的下载与安装"></a><em>环境的下载与安装</em></h3><p>　　<strong>第一步：首先先下载git和 node.js：</strong><br>　　下载并安装git：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZC93aW4=" title="https://git-scm.com/download/win">https://git-scm.com/download/win<i class="fa fa-external-link"></i></span><br>　　下载并安装node.js ；<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL2N1cnJlbnQv" title="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/<i class="fa fa-external-link"></i></span>  </p><p>　　具体安装流程这里不再叙述，直接默认安装即可。当上面两个都下载安装完毕后,搭建Hexo框架：  </p><p>　　<strong>第二步：先在E盘(自行选择）中建立一个Hexo文件夹用于存储本地文件</strong>,如下图。有这么多文件是因为我已经搭建好了</p><p>   <img src="hexo%E6%90%AD%E5%BB%BA_hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E5%BB%BA%E7%AB%8B.png" alt="图片加载失败"></p><p>　　<strong>第三步：进入文件夹对着空白处右键，选中Git Bash Here(如果你成功安装Git的话)，依次输入以下命令：</strong></p><ul><li><p>安装Hexo：<code>npm install -g hexo-cli</code></p></li><li><p>初始化Hexo: <code>hexo init</code></p><p> 此时，指定文件夹的目录大致如下：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre></li><li><p>启动Hexo服务: <code>hexo clean</code>(清理静态文件) –&gt;<code>hexo generate</code>(生成静态文件)–&gt;<code>hexo server</code>(部署到本地)</p></li></ul><p>　　执行以上命令之后，hexo就会在public文件夹生成相关html文件，如下图</p><p>   <img src="hexo%E6%90%AD%E5%BB%BA_helloworld.png" alt="图片加载失败"></p><p>　　<strong>第四步：输入hexo server后，如果成功，则可访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw" title="http://localhost:4000">http://localhost:4000<i class="fa fa-external-link"></i></span> 查看这个页面。在控制台按Ctrl+C可退出预览</strong></p><p>   <img src="hexo%E6%90%AD%E5%BB%BA_hexoServer.png" alt="图片加载失败"></p><p>　　至此基本环境已近安装完毕,更多详细内容可参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv" title="https://hexo.io/zh-cn/docs/">官方文档<i class="fa fa-external-link"></i></span>  </p><h3 id="服务器的部署"><a href="#服务器的部署" class="headerlink" title="服务器的部署"></a><em>服务器的部署</em></h3><p>　　想要稳定地运行网站(博客)，需要购买一个自己的服务器。但里我们使用GitHub仓库(当然是因为免费啦)，相当于借用了GitHub的服务器。</p><p>　　服务器部署大致如下：</p><p>　　<strong>第一步：注册/登录github： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">https://github.com/<i class="fa fa-external-link"></i></span></strong> (不会就问问度娘吧~)</p><p>　　<strong>第二步：初始化仓库：新建(New)一个仓库。新建仓库名字为：用户名 + .github.io。</strong></p><p>   <img src="hexo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2_%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt="图片加载失败"></p><p>　　<strong>第三步：新建完成后，选择第一个(六行命令那个)复制</strong></p><p>   <img src="hexo%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA_github%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B.png" alt="图片加载失败"></p><p>　　<strong>第四步：然后在刚才建的Hexo文件夹打开Git Bash命令窗口进行粘贴。</strong></p><p>   <img src="hexo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2_git%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4.png" alt="图片加载失败"></p><p>　　<strong>第五步：打开并配置_config.yml中有关deploy的部分，修改如下,注意将<code>name</code>改为你的用户名</strong></p><pre><code>deploy:  type: git  repository: https://github.com/name/name.github.io.git  branch: master</code></pre><p>　　<strong>第六步：然后在hexo文件夹打开git bash窗口，输入<code>hexo deploy</code>就会将本次有改动的代码全部提交，这时刷新你的GitHub页面即可看到已提交的文件</strong></p><p>　　PS:上传前建议配置一个<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vZ2l0aHViL2F1dGhlbnRpY2F0aW5nLXRvLWdpdGh1Yi9jb25uZWN0aW5nLXRvLWdpdGh1Yi13aXRoLXNzaA==" title="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">SHH key<i class="fa fa-external-link"></i></span>,上传时不用输入账号密码还能防止别人攻击。当然不配置也可以。  </p><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a><em>购买域名</em></h3><p>　　当环境和服务器的基本环境都已搞定后，就需要去购买一个域名，以便使博客能够通过互联网被访问。</p><p>　　去阿里云购买一个域名 <span class="exturl" data-url="aHR0cDovL3d3dy5hbGl5dW4uY29t" title="http://www.aliyun.com">www.aliyun.com<i class="fa fa-external-link"></i></span> (当然其他也行)，根据自己经济能力购买即可</p><p>　　<img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0.png" alt="图片加载失败"></p><p>　　购买后还要进行一系列的验证和备案这里就跳过了  </p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a><em>域名解析</em></h3><p>　　<strong>第一步：购买成功进行备案后。找到阿里云的域名控制台进行域名解析</strong></p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="图片加载失败"></p><p>　　<strong>第二步： 进行新手引导</strong></p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%901.png" alt="图片加载失败"></p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%902.png" alt="图片加载失败"></p><p>　　<strong>第三步;网站解析设置完后，修改记录值</strong></p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%903.png" alt="图片加载失败"></p><p>　　<strong>第四步；修改完可以打开命令行窗口进行ping操作，查看是否能与服务器通信</strong></p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_ping.png" alt="图片加载失败"></p>   <br><p>　　此外还有两个地方要修改：</p><p>　　A、 source文件的CNAME记录：</p><p>　　创建方式:右键新建txt文本-&gt;输入你购买的域名 <span class="exturl" data-url="aHR0cDovL3d3dy5jaGlheWhvbmwudG9w" title="http://www.chiayhonl.top">www.chiayhonl.top<i class="fa fa-external-link"></i></span> -&gt; 保存关闭 -&gt; 去掉.txt后缀</p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_cname%E8%AE%B0%E5%BD%951.png" alt="图片加载失败"></p><p>　　B、 服务器绑定域名：</p><p>　　找到仓库的setting页面，拉倒最下面</p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.png" alt="图片加载失败"></p><p>   <img src="%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D2.png" alt="图片加载失败"></p><p>　　到这博客基本框架已搭建完毕,输入购买的域名 <span class="exturl" data-url="aHR0cDovL3d3dy5jaGlheWhvbmwudG9w" title="http://www.chiayhonl.top">www.chiayhonl.top<i class="fa fa-external-link"></i></span> 便会显示出自己博客的首页。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　搭博客需要一个理由.关于为什么要自己搭建一个博客,我想是在看到别人清晰有条理的布局与归类后,为了改善自己归纳整理的能力,于是决定自己搭一个(其实更多是冲着看板娘去的).捣鼓了一个下午之后,终于搞清楚一点门路.就以此记录一点心得吧&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/tags/Hexo/"/>
    
  </entry>
  
</feed>
