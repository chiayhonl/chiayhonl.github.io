<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Chiayhon&#39;s Blog</title>
  
  <subtitle>Is it lazy bee today?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chiayhonl.top/"/>
  <updated>2019-11-15T16:45:52.934Z</updated>
  <id>http://chiayhonl.top/</id>
  
  <author>
    <name>Chiayhon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>努力学习Linux(二)：Linux系统的安装</title>
    <link href="http://chiayhonl.top/archives/fb88f67d.html"/>
    <id>http://chiayhonl.top/archives/fb88f67d.html</id>
    <published>2019-11-15T06:07:22.000Z</published>
    <updated>2019-11-15T16:45:52.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本篇将介绍在Windows系统下安装Linux系统相关资料，以及具体安装教程及注意事项。  </p><br><a id="more"></a><h2 id="安装资料"><a href="#安装资料" class="headerlink" title="安装资料"></a>安装资料</h2><h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><p>　　在上篇<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwL2FyY2hpdmVzLzYwODM2NTMxLmh0bWw=" title="http://localhost:4000/archives/60836531.html">《努力学习Linux(一)：Linux的前世今生》<i class="fa fa-external-link"></i></span>最后我们提到Linux版本分为内核版本和发行版本，这里我们选择安装的Linux系统是其一种发行版本 CentOS。Linux有非常多的发行版本，从性质上划分，大体分为由商业公司维护的商业版本与由开源社区维护的免费发行版本。商业版本以Redhat为代表，开源社区版本则以debian为代表。下面是三个典型的发行版：  </p><ul><li><strong>Ubuntu</strong>：Ubuntu最大特点是有着漂亮的用户界面，这个特点决定了它最佳的应用领域是桌面操作系统而非服务器操作系统。如果你想把Windows系统换成Linux系统，那么Ubuntu是个不错的选择。但我们所需要的只是一个简约、稳定、易用的服务器系统来学习Linux而已，所以不选择这个版本。</li><li><strong>CentOS</strong>：它是redhat源代码编译重新发布版，CentOS去除很多与服务器功能无关的应用。CentOS简约，命令行下的人性化做得比较好，稳定，有着强大的英文文档与开发社区的支持。许多商业公司部署在生产环境上的服务器都是使用的CentOS系统，一般适合新手入门。</li><li><strong>Debian</strong>：Debian可以说是CentOS低配版，debian整个系统基础核心非常小，不仅稳定，而且占用硬盘空间小，占用内存小。128M的VPS即可以流畅运行Debian，而CentOS则会略显吃力。但是由于Debian的发展路线，使它的帮助文档相对于CentOS略少，技术资料也少一些。  </li></ul><p>　　对于初学者，我们建议采用CentOS或Debian，这两种系统都能在配置较低的VPS上流畅运行。但是如果VPS配置太低（OPENVZ内存在128M以下，或者XEN架构内存在192M以下），建议采用Debian；否则建议采用CentOS，以获取更多的在线帮助与支持，让自己入门更轻松。<br>　　我们虽然选择学习的是CentOS,但是大家也不要在意，基本上学会一个系统的命令后，其余的系统都大同小异。我们是将CentOS安装在虚拟 PC，这里模拟虚拟PC的软件选择 VMware。  </p><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3><p>　　CentOS我们选择阿里云站点进行下载，进入页面选择CentOS-8-x86_64-1905-dvd1.iso下载即可。VMware是虚拟软件，用于模拟虚拟PC运行CentOS。<br>　　此外再推荐两个软件：Xshell 6和WinSCP。因为在虚拟机系统和本机系统之间的切换，我们可以通过Xshell 6能在本机系统中控制虚拟机系统，方便我们在查资料时进行相关操作。如果我们想向Linux机器上传文件，我们该怎么办呢？这就是WinSCP存在的原因了。</p><ul><li><strong>CentOS 8</strong>：链接<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmFsaXl1bi5jb20vY2VudG9zLzgvaXNvcy94ODZfNjQv" title="https://mirrors.aliyun.com/centos/8/isos/x86_64/">https://mirrors.aliyun.com/centos/8/isos/x86_64/<i class="fa fa-external-link"></i></span></li><li><strong>VMware 15.5</strong>：链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWJ2SEdlRkczcWhMTXl0cTJXajBWbHc=" title="https://pan.baidu.com/s/1bvHGeFG3qhLMytq2Wj0Vlw">https://pan.baidu.com/s/1bvHGeFG3qhLMytq2Wj0Vlw<i class="fa fa-external-link"></i></span> 提取码: 4e9b  </li></ul><p>辅助工具： </p><ul><li><strong>Xshell 6</strong>：链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTVJX1JrNmtkT1RBT0lrLVhYbGxjUEE=" title="https://pan.baidu.com/s/15I_Rk6kdOTAOIk-XXllcPA">https://pan.baidu.com/s/15I_Rk6kdOTAOIk-XXllcPA<i class="fa fa-external-link"></i></span> 提取码: y7r1</li><li><strong>WinSCP</strong>: 链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUYyLS0tZWxHSmxrTzNjejY3OWs1Qnc=" title="https://pan.baidu.com/s/1F2---elGJlkO3cz679k5Bw">https://pan.baidu.com/s/1F2---elGJlkO3cz679k5Bw<i class="fa fa-external-link"></i></span> 提取码: me32 </li></ul><br><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>　　除了CentOS的安装较为繁琐，其他三个都比较简单，这里就着重介绍centOS安装步骤。  </p><h3 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h3><p>　　VMware 是一个虚拟 PC 的软件，可以在现有的操作系统上虚拟出一个新的硬件环境，相当于模拟出一台新的 PC，我们可以在上面构造出一个或多个别的系统，以此来实现在一台机器上真正同时运行多个独立的操作系统。VMware 下载链接上面给出了，安装过程都是默认下一步，下一步即可。这里就不给出安装的图示了，安装完成后，双击打开如下：<br><img src="http://q107fztjj.bkt.clouddn.com/2-VMware_%E5%9B%BE%E7%A4%BA.png" alt="VMware"></p><h3 id="centOS安装"><a href="#centOS安装" class="headerlink" title="centOS安装"></a>centOS安装</h3><p>第 1 步：打开 VMware，点击创建新的虚拟机，选择典型<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA.png" alt="新建虚拟机"></p><p><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA2.png" alt="新建虚拟机"></p><p>第 2 步：出现如下界面，然后选择第三个选项。<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA3.png" alt="新建虚拟机"></p><p>第 3 步：客户机安装操作系统选择 Linux,版本根据自己下载的 Linux 镜像文件来选择，本人版本如下。然后点击 下一步<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA4.png" alt="新建虚拟机"></p><p>第 4 步：给虚拟机命名，以及选择虚拟机安装的位置，<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA5.png" alt="新建虚拟机"></p><p>第 5 步：默认<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA6.png" alt="新建虚拟机"></p><p>第  6 步：点击完成按钮<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA7.png" alt="新建虚拟机"><br>完成之后的界面<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA8.png" alt="虚拟机界面"></p><p>第 7 步：右键 虚拟机名称MyLinux,选择设置，首先调整内存大小，我们可以默认选择内存大小就够了。可以自行调整<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA9.png" alt="虚拟机界面"></p><p>第 8 步：跳到 CD/DVD(IDE) 选项，选择我们下载的 CentOS 镜像文件，然后点击确定<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA10.png" alt="虚拟机界面"></p><p>那么经过上面的步骤，我们对于虚拟机的配置已经设置完成，接下来就进行虚拟机的安装。</p><p>第 9 步：到 VMware 主界面，选择 我们安装的 Node2 虚拟机，点击 开启此虚拟机<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA11.png" alt="虚拟机界面"></p><p>第 10 步：当系统从 CentOS 8 ISO 启动介质启动之后，就可以看到以下这个界面。选择“Install CentOS Linux 8.0。1905”（安装 CentOS Linux 8.0）选项并按回车。<br>注意：我们鼠标进入安装界面后，需要按 Ctrl+Alt 才能使得鼠标恢复到自己的主系统。<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA12.png" alt="虚拟机界面"></p><p>第 11 步：选择语言<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA13.png" alt="设置界面"></p><p>第 12 步：我们要设置四个地方<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA14.png" alt="设置界面"><br>A：设置网络<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA17.png" alt="设置界面"><br>B：设置时间<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA15.png" alt="设置界面"><br>C：设置安装目的地,这里可以自动或者手动进行分区，我们选择默认即可<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA15.1.png" alt="设置界面"></p><p><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA15.2.png" alt="设置界面"></p><p><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA15.3.png" alt="设置界面"></p><p><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA15.4.png" alt="设置界面"><br>D：软件选择：第一个会安装图形化界面，第三个是只实现最基本功能。进行学习的话建议选择最小安装，舍弃图形化界面。右边是附加选项，根据个人需求选择。<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA15.5.png" alt="设置界面"></p><p>第 13 步：设置完成后，开始安装<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA18.png" alt="设置界面"></p><p>第 14 步：设置超级管理员密码和添加用户，不建议直接使用超级管理员账户(root)进行操作，这里设置一个admin账户权限为管理员。然后等待安装完成<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA19.png" alt="设置界面"></p><p>第 15 步：安装完成后重启虚拟机，然后会进入命令行界面，进行输入账号，这里可以选择用超级管理员root账户或者刚才创建管理员账户admin登录<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA24.png" alt="登录"><br>注意，输入密码时是不会显示的，输入完直接敲回车就行。出现如下命令行说明登陆成功<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA25.png" alt="登录"></p><p>对于选择图形化界面的同学，直接点账户输入密码即可：<br><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA29.png" alt="登录"></p><p><img src="http://q107fztjj.bkt.clouddn.com/2-centOS_%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA31.png" alt="图形化界面"></p><p>至此CentOS安装完毕。</p><h3 id="Xshell-6"><a href="#Xshell-6" class="headerlink" title="Xshell 6"></a>Xshell 6</h3><p>　　安装完centOS我们会发现在Linux虚拟机中操作命令发现特别繁琐，而且在虚拟机系统和本机系统之间的切换比较麻烦。这里我们可以使用前面提到的Xshell 6解决这个问题。<br>　　打开Xshell 6 ，选择新建会话：<br><img src="http://q107fztjj.bkt.clouddn.com/2-xsell_%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D.png" alt="新建会话"><br>　　新建完成如下：<br><img src="http://q107fztjj.bkt.clouddn.com/2-xsell_%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D2.png" alt="新建会话"><br>　　选择一个账户连接即可对其进行操作，是不是很方便呢？<br><img src="http://q107fztjj.bkt.clouddn.com/2-xsell_%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D3.png" alt="连接">　　</p><h3 id="WinSCP"><a href="#WinSCP" class="headerlink" title="WinSCP"></a>WinSCP</h3><p>　　同理该软件安装步骤也很简单，安装完成之后，我们打开该软件，进行如下的配置：<br><img src="http://q107fztjj.bkt.clouddn.com/2-winscp_%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D.png" alt="新建连接"><br>　　左边是Windows系统，右边是Linux系统，可直接进行复制粘贴操作。<br><img src="http://q107fztjj.bkt.clouddn.com/2-winscp_%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D2.png" alt="操作界面"></p><p>以上如果能帮到你那是最好不过了，好啦这就是本篇的全部内容了~</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本篇将介绍在Windows系统下安装Linux系统相关资料，以及具体安装教程及注意事项。  &lt;/p&gt;
&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://chiayhonl.top/categories/Linux/"/>
    
    
      <category term="安装教程" scheme="http://chiayhonl.top/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="http://chiayhonl.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>努力学习Linux(一)：Linux的前世今生</title>
    <link href="http://chiayhonl.top/archives/60836531.html"/>
    <id>http://chiayhonl.top/archives/60836531.html</id>
    <published>2019-11-13T08:52:19.000Z</published>
    <updated>2019-11-15T06:24:39.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本篇将对Linux的历史背景进行相应简单的叙述，仅当做拓展阅读，不感兴趣的读者大可跳过本章节。<br><br></p><a id="more"></a>    <h2 id="Multics计划"><a href="#Multics计划" class="headerlink" title="Multics计划"></a>Multics计划</h2><p>　　上个世纪六十年代，那个计算机还没有很普及，只有少数人才能使用。<br>　　当时的计算机系统都是批处理的，就是把一批任务一次性提交给计算机，然后就等待结果。并且中途不能和计算机交互。往往准备作业都需要花费很长时间，并且这个时候别人也不能用，导致了计算机资源的浪费。<br>　　为了改变这种情况，在1965年前后，贝尔实验室（Bell）、麻省理工学院（MIT）以及通用电气（GE）联合起来准备研发一个分时多任务处理系统。<br>　　多任务处理系统简单来说就是实现多人同时使用计算机的梦想，并把计算机取名为Multics（多路信息计算系统），但是由于项目太复杂，加上其他原因导致了项目进展缓慢，1969年贝尔实验室觉得这个项目可能不会成功，于是就退出不玩了。<br><br></p><h2 id="Unix的诞生"><a href="#Unix的诞生" class="headerlink" title="Unix的诞生"></a>Unix的诞生</h2><p>　　Bell退出Multics计划之后，Bell实验室的那批科学家就没有什么事做了，其中一个叫做Ken Thompson的人在研发Multics的时候，写了一个叫做太空大战（Space Travel）的游戏，大概就是一个很简单的打打飞机什么的(不是你想的那种)。<br>　　但是呢，这个游戏运行在Multics上的，当Bell退出了Multics项目后，Thompson就没有了Multics的运行环境了。为了能够继续游戏，于是他花了一个月的时间写了一个小型的操作系统，用于运行Space Travel(游戏是工作第一驱动力！)。当完成之后，Thompson怀着激动的心情把身边同事叫过来，让他们来玩他的游戏，大家玩过之后纷纷表示对他的游戏不感兴趣，但是却对他的系统很感兴趣。<br>　　因为MULTICS是“Multiplexed informtion and Computing Service”的缩写（多路信息计算系统），于是他们命名这个系统为：“UNiplexed Information and Computing Service”，缩写为“UNICS”(没路信息计算系统，与Multics相反)。后来大家取其谐音，就称其为“UNIX”了。<br>　　这个时候已经是1970年了，于是就将1970年定为Unix元年，因此计算机上的时间就是从这一年开始计算的。<br>　　后来Unix这个小操作系统就在Bell实验室内部流行开，并经过不断地改良最终在1974年7月Unix发展到第5个版本，Bell实验室公开了Unix，结果引起了学术界的广泛兴趣并对其源码索取。所以，Unix第五个版本就以“仅用于教育目的”的协议，提供给各大学作为教学之用，成为当时操作系统课程的范例教材。各大学公司开始通过Unix源码对Unix进行了各种各样的改进和拓展。　　<br>　　1978年学术界的老大伯克利大学，推出了一份以第六版为基础，加上一些改进和新功能而成的Unix。并命名为BSD（Berkeley Software Distribution伯克利分发版），开创了Unix的另一分支：BSD系列。<br>　　于是乎Unix就有了两个分支，一个就是BSD系列的分支，一个就是Bell本身发放的分支，当时因为Bell属于AT&amp;T，AT&amp;T受到了美国《谢尔曼反托拉斯法》的影响，不能销售除了电话机电报机等之外的商品，后来AT&amp;T分解，Bell可以卖Unix了，Unix走向了商业化，如果想继续使用就需要购买授权，一份授权4万美元。<br><br></p><h2 id="GNU计划"><a href="#GNU计划" class="headerlink" title="GNU计划"></a>GNU计划</h2><p>　　软件产业在70年代成就了两位针锋相对的领袖人物，来自哈佛大学的比尔·盖茨和理查德(Richard M.Stallman)。前者宣布了Copyright(版权)时代的到来，并构建了微软帝国的辉煌；后者于1984年创立自由软件体系GNU，拟定普遍公用版权协议（GeneralPublicLicense，简称GPL），可以说今天Linux的成功就得益于GPL协议。<br>　　理查德被人们誉为自由软件之父，同时他是一个非常“激进”的人。因为Unix商业化的影响，他认为软件是全人类的智慧结晶，不应该为某一家公司服务。在八十年代，他发起了自由软件运动，吹起了共产主义的号角（发起了GNU运动），并发布了软件界的共产主义宣言（GPL协议），并且这一运动得到了很多人的认同。<br>　　所谓自由软件自由就是指：自由使用、自由学习和修改、自由分发、自由创建衍生版。<br>　　GNU的定义是一个递归缩写，就是GNU IS NOT UNIX。就是说Unix是流氓，我不是。有意思的是，GNU运动是1984年开始的，而那个时候Linux系统还没有诞生呢，所以Stallman宝宝心里苦啊，就在大家逐渐失去信心的时候，1991年Linus Torvalds带着他的Linux闪亮登场了，给GNU运动画了一个完美的句号。<br><br></p><h2 id="Minix的诞生"><a href="#Minix的诞生" class="headerlink" title="Minix的诞生"></a>Minix的诞生</h2><p>　　在1981 年，IBM 公司推出了享誉全球的微型计算机IBM PC。在1981-1991 年间，MS-DOS 操作系统 一直是微型计算机操作系统的主宰。此时计算机硬件价格虽然逐年下降，但软件价格仍然居高不下 。<br>　　当时Apple 的MACs 操作系统可以说是性能最好的，但是其天价使得没人能够轻易靠近。<br>　　另一个计算机技术阵营就是UNIX 世界。但是UNIX 操作系统就不仅是价格昂贵的问题 了。为了寻求高利润率，UNIX 经销商们把价格抬得极高，PC 小用户根本不能靠近它。曾经一度收到Bell Labs许可而能在大学中用于教学的UNIX 源代码也一直被小心地守卫着不许公开。<br>　　对于广大的PC 用户，软件行业的大型供应商们始终没有给出有效的解决这个问题的手段。<br>　　而在Unix昂贵的授权费用下，很多大学不得不停止对其研究，老师导致上课也不知道讲什么了。于是终于在1987年荷兰有个大学教授安德魯(Andrew S. Tanenbaum 简称AST)写了一个Minix，类似于Unix，主要用于学生学习操作系统原理。<br>　　在MINIX 操作系统的出现的同时，一本描述其设计实现原理的书与其同时发行。由于AST的这本书写的非常详细，并且叙述得有条有理，于是几乎全世界的计算机爱好者都开始看这本书，以期能理解操作系统的工作原理。<br>　　当Minix流传开来之后，世界各地的黑客们纷纷开始使用并改进，希望把改进的东西合并到Minix中，但是安德鲁觉得他的系统是用于教学的，不能破坏纯净性，于是拒绝了。<br>　　虽然作为一个操作系统，Minix 并不是优秀者，但它最大的意义在于提供了用C 语言和汇编语言编写的系统源代码。这是第一次使得有抱负的程序员或hacker 能够阅读操作系统的源代码。在当时，这种源代码可是软件商们一直小心守护着的秘密。<br><br></p><h2 id="Linux的诞生"><a href="#Linux的诞生" class="headerlink" title="Linux的诞生"></a>Linux的诞生</h2><p>　　MINIX 操作系统流传引来了一大批计算机爱好者，  其中也包括Linux 系统的创始者林纳斯.托瓦兹(Linus Benedict Torvalds)。当时(1991 年)，Linus是赫尔辛基大学计算机科学系的二年级学生，也是一个自学的计算机hacker。这个21岁的芬兰年轻人喜欢鼓捣他的计算机，测试计算机的性能和限制。但当时他所缺乏的就是一个专业级的操作系统。<br>　　在同一年间，GNU 计划已经开发出了许多工具软件。其中最受期盼的GNU C 编译器已经出现，但还没有开发出免费的GNU 操作系统。 即使是教学使用的MINIX 操作系统也开始有了版权，需要购买才能得到源代码。虽然GNU 的操作系统HURD一直在开发之中，但在当时看来不能在几年内完成。<br>　　为了能更好地学习计算机知识（或许也只是为了兴趣），Linus 使用圣诞节的压岁钱和贷款购买了一台386 兼容电脑 ，并从美国邮购了一套MINIX 系统软件 。就在等待MINIX 软件期间，Linus 认真学习了有关Intel 80386 的硬件知识。为了能通过Modem 拨号连接到学校的主机上，他使用汇编语言并利用80386 CPU的多任务特性编制出一个终端仿真程序。此后为了将自己一台老式电脑上的软件复制到新电脑上，他还为软盘驱动器、键盘等硬件设备编制出相应的驱动程序（他编写了一些os相关的程序）。<br>　　通过编程实践，并在学习过程中认识到MINIX 系统的诸多限制（MINIX 虽然很好，但只是一个用于教学目的简单操作系统，而不是一个强有力的实用操作系统），而且通过上述实践Linus 已经有了一些类似于操作系统硬件设备驱动程序的代码，于是他开始有了编制一个新操作系统的想法。（一个影响深远的想法诞生了）。<br>　　从1991 年4 月 份开始，Linus 几乎花费了全部时间研究MINIX-386 系统(Hacking the kernel)，并且尝试着移植GNU 的软件到该系统上(GNU gcc、bash、gdb 等)。并于4 月13 日在comp.os.minix 上发布说自己已经成功地将bash 移植到了MINIX 上，而且已经爱不释手、不能离开这个shell 软件了。<br>　　在1991年9月17日，Linus在互联网上公布了自己写的Linux，可能是表达对安德鲁的不满吧（为什么不接受大家的好意呢？你让大家的满腔热情往哪放呢？），于是Linus发布了一个帖子，大概就是说：我写了一个操作系统的内核，但是还不够完善，你们以任何姿势使用不收费，也可以帮助我一起修改。帖子发出后引起了强烈的反响。在大家的努力下，于1994年Linux的1.0版本正式发布。<br>　　Linux为什么会引起如此强烈的反响呢？因为Unix有版权，爱好编程的狂热分子在研究Unix的时候很容易吃上官司 ，而Linux是遵循GPL协议的，可以免费使用，让黑客们尽情的施展（这里的黑客指那些技术大牛，不是指那些利用计算机干坏事的人）。于是Linux提供内核（kernel），GNU提供外围软件，就这样GNU/Linux诞生了。<br>　　所以，看到这里你就会了解到Unix是1970年出现的，Linux是1991年发布的，但Linux是不同于Unix的操作系统。<br><br></p><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>　　上面主要介绍了Linux以及Unix的一些历史故事，下面则介绍操作系统方面的知识。在进入正题之前，我们先简单了解一下操作系统。<br>　　我们都知道，CPU是由运算器和控制器组成的，程序在运行的时候就是调用CPU的指令进行一些运算操作，例如加减乘除。CPU能够调用的指令集合，就是指令集。但是不幸的是CPU的生产厂家不止一家，例如Intel、AMD等。即便是同一家厂商生产CPU，不同平台之间的指令集也不一样。那么程序员在编写程序的时候会遇到一个尴尬的局面，就是当你在某一个平台编码的时候，如果想将程序移到另外一个平台上，就需要重新编码，重新编码还不是最可怕的，可怕的是你得学习对应的新平台的指令集。<br>　　一般而言，我们称直接在硬件层面上进行编程是硬件规格层的编程（hardware spaceifiacation），例如调用CPU提供的指令等。你需要知道的是，不同硬件提供的API是个不相同的。如果程序员要编程还得精通硬件那得多难，所以我们需要一个<strong>通用软件</strong>来<strong>提供统一接口，以屏蔽硬件的差异化</strong>。这个通用软件就是操作系统。<br>　　操作系统将底层硬件提供的接口进行封装，程序员直接调用由操作系统提供的接口，也称为<strong>系统调用</strong>。但是系统封装的接口会很多吗？显然不会很多，因为如果操作系统提过几万个接口，程序员还不累的学出血。<br>　　一般而言，系统提供的接口都是短小精悍，我们需要像搭积木一样，将其组装起来提供更为丰富的功能，并且将组装好的代码做成库，供别人使用。这样一来，就是<strong>库调用</strong>。在Windows上库一般都是dll（Dynamic Link Library），而在Linux或者Unix上我们一般称之为so（shared object），就是共享的代码，大家都可以调用。<br>　　现在我们知道了，操作系统的一个<strong>重要功能</strong>就是<strong>将硬件提供的功能进行封装，我们调用操作系统提供的接口就是系统调用（system call）。然后将系统提供的接口组合后形成更丰富的库</strong>。当然操作系统还有其他的功能，例如CPU的时间分片、安全保证等。<br><br></p><h2 id="Linux的发行版本"><a href="#Linux的发行版本" class="headerlink" title="Linux的发行版本"></a>Linux的发行版本</h2><p>　　我们知道Linux或者Unix是一个操作系统，1991年的Linus Torvalds公布的是Linux的内核（kernel）。但是要注意的是，公布的是源码，并不是编译好的直接可安装的操作系统，我们如何安装一个操作系统呢？很简单啊，就是先下载一份源码，然后进行编译安装，但是编译的时候程序需要运行在操作系统上啊，操作系统呢？还没有编译呢。于是就陷入了一个死循环中，就是我们要安装操作系统，就需要编译，编译的时候需要操作系统，这样就是鸡生蛋，蛋生鸡。<br>　　这里就需要引入<strong>交叉编译</strong>了，具体做法是假设我们要在电脑上安装Linux，我们把A的硬盘拆下来，放到已经安装了操作系统的电脑B上，然后编译，将编译好的操作系统放到硬盘上，再把硬盘装回去，开机启动，这就是交叉编译安装系统。<br>　　这得有多难啊，入门难度实在太高了，所以我们迫切需要一种简单的方式来安装。于是就出现了这么一种公司，他们将已经公开好的Kernel（内核）再加上一些开源的周边软件收集起来编译成二级制文件放到网上供别人使用，其中<strong>Red Hat</strong>（红帽）就是其中著名的一家。<br>　　我们知道Linux是遵循GPL协议的，也就是公开免费的，那么他们怎么盈利呢？既然不能卖软件，那么就卖服务呗，比如说，发现了Linux漏洞，然后Red Hat修复，如果你买了我们的服务，我们就将补丁程序给你，并指导你安装，所有问题都帮你解决。<br>　　世界上总是不缺好事者，RedHat既然可以这么做，为什么就不能有好心人免费做呢？是的，有这样一个社区，他们把RedHat的源码拿过来，然后编译成操作系统放出去，这就是<strong>CentOS</strong>，就是社区版的RedHat，所以基本RedHat的补丁包出来一个月之后，CentOS就出现对应的补丁包了。这对于Red Hat是好事还是坏事呢？这恐怕只有当事人知道了，不过在2014年年初传来消息，RedHat收编了CentOS的团队。就像MSDN I TELL YOU 上面都是微软的正版软件，可以随便下载，但是这不也是为微软做了免费宣传吗。<br>　　当别人说Linux的版本时，一般来说有两个版本，一个是内核的版本，一个是发行的版本。例如登录到终端执行命令<br><br></p><h2 id="Linux的哲学思想"><a href="#Linux的哲学思想" class="headerlink" title="Linux的哲学思想"></a>Linux的哲学思想</h2><p>　　&lt;1&gt;一切皆文件，把几乎所有的资源都组织成文件的格式，我们只需要一个文本编辑工具，就可以修改工作的特性了，很方便。<br>　　&lt;2&gt;组合小程序，完成复杂任务，例如将系统调用组合形成库（在Linux就是so结尾的文件）。<br>　　&lt;3&gt;尽量避免和用户交互，Windows上就是弹框，让你点确定。在Linux上，如果执行一个程序之后没有任何提示，那就是最后的提示。<br>　　&lt;4&gt;使用纯文本文件保存配置信息，这个在第一点就可以看出来。<br><br></p><p>参考资料：<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5b250ZS9hcnRpY2xlL2RldGFpbHMvNjA3NjAwMw==" title="https://blog.csdn.net/lyonte/article/details/6076003">https://blog.csdn.net/lyonte/article/details/6076003<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTIzNTkzL2FydGljbGUvZGV0YWlscy82MzY4Mzg1Ng==" title="https://blog.csdn.net/qq_35523593/article/details/63683856">https://blog.csdn.net/qq_35523593/article/details/63683856<i class="fa fa-external-link"></i></span></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本篇将对Linux的历史背景进行相应简单的叙述，仅当做拓展阅读，不感兴趣的读者大可跳过本章节。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://chiayhonl.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://chiayhonl.top/tags/Linux/"/>
    
      <category term="简介" scheme="http://chiayhonl.top/tags/%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——《高性能MySQL》</title>
    <link href="http://chiayhonl.top/archives/8dd2f4b9.html"/>
    <id>http://chiayhonl.top/archives/8dd2f4b9.html</id>
    <published>2019-11-12T05:10:31.000Z</published>
    <updated>2019-11-15T06:24:39.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/spoiler.css&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;/js/spoiler.js&quot; type=&quot;text/javascript&quot; async&gt;&lt;/script&gt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://chiayhonl.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="http://chiayhonl.top/tags/MySQL/"/>
    
      <category term="读书笔记" scheme="http://chiayhonl.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer(更新中)</title>
    <link href="http://chiayhonl.top/archives/d85b83df.html"/>
    <id>http://chiayhonl.top/archives/d85b83df.html</id>
    <published>2019-11-12T00:13:20.000Z</published>
    <updated>2019-11-15T16:45:52.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本文将对剑指offer的题型进行整理，包括解题思路和代码实现。分类依据则是基于题目的侧重考点进行分类。</p><a id="more"></a><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><em>反转链表</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzc1ZTg3OGRmNDdmMjRmZGM5ZGMzZTQwMGVjNjA1OGNhP3RwSWQ9MTMmdHFJZD0xMTE2OCZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_24<i class="fa fa-external-link"></i></span></p><p><strong>题目描述</strong></p><p><img src="http://q103n68fw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer_24.jpg" alt="剑指offer-24"></p><p><strong>解题思路</strong></p><p>　　反转链表链表大体思路就是将链表中的各个结点的<code>next</code>指针指向前一个，实现链表反转。   </p><p>　　递归版本思路：将当前结点后面的链表进行反转，然后将当前结点作为反转后链表的后继结点。<br>　　非递归版本思路：用两个变量记录当前结点的前驱和后继结点，前者用来反转当前结点的指向，后者用来记录下一个要反转的结点  </p><p><strong>代码实现</strong>  </p><p>　　递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果传入的头结点为空，返回null</span></span><br><span class="line">           <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)    <span class="keyword">return</span> head; <span class="comment">//如果传入的头结点下一结点指向为null，说明链表长度为1或者已经到链表尾部，返回自身</span></span><br><span class="line">           ListNode newHead = ReverseList(head.next);<span class="comment">//反转当前结点后的链表，并返回反转后的新表头</span></span><br><span class="line">           head.next.next = head;<span class="comment">//将当前结点下一结点的next指针指向自己，即将当前结点接入反转后链表，</span></span><br><span class="line">           head.next = <span class="keyword">null</span>;<span class="comment">//将当前结点的next指针指向空，完成反转</span></span><br><span class="line">           <span class="keyword">return</span> newHead;<span class="comment">//返回反转后的新表头</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　非递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果传入的头结点为空，返回null</span></span><br><span class="line">           ListNode pre = <span class="keyword">null</span>;<span class="comment">//定义当前结点的前驱结点</span></span><br><span class="line">           ListNode next = <span class="keyword">null</span>;<span class="comment">//定义当前结点的后继结点</span></span><br><span class="line">           <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;<span class="comment">//进行反转操作，当当前结点为空时跳出循环，即所有结点都以反转完毕</span></span><br><span class="line">               next = head.next;<span class="comment">//传入当前结点的后继结点</span></span><br><span class="line">               head.next = pre;<span class="comment">//进行反转，当前结点指向前驱结点</span></span><br><span class="line">               pre = head;<span class="comment">//反转完成，准备下一次反转，前驱结点和当前结点都向后移动</span></span><br><span class="line">               head = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pre;<span class="comment">//当前结点为空时，前驱结点在链表尾部指向新表头</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　非递归优化：实例化用一个临时结点，使其<code>next</code>指针指向当前结点的前驱结点，避免当前结点为空的判断，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//实例化临时结点</span></span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = temp.next;</span><br><span class="line">            temp.next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.next;<span class="comment">////当前结点为空时，前驱结点在链表尾部指向新表头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><em>从尾到头打印链表</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2QwMjY3ZjdmNTViMzQxMmJhOTNiZDM1Y2ZhOGU4MDM1P3RwSWQ9MTMmdHFJZD0xMTE1NiZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_6<i class="fa fa-external-link"></i></span>  </p><p><strong>问题描述</strong>  </p><p><img src="http://q103n68fw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer_6.jpg" alt="剑指offer-6"></p><p><strong>解题思路</strong>  </p><p>　　思路推荐：  </p><p>　　头插法：利用ArrayList集合的<strong>add(int index , E element)方法</strong>，逐个将结点从集合头部插入。</p><p>　　递归思路：将传入结点后面的链表反转并加入ArrayList集合，最后将传入结点加入到ArrayList集合末尾。  </p><p>　　利用Collections类：通过调用Collections里的<strong>reverse方法</strong>即可实现反转。  </p><p>　　利用栈：利用栈的<strong>先进后出</strong>特性实现链表反转输出<br><br><br>　　不推荐：  </p><p>　　自实现：借用上题自实现的反转方法，反转后加入ArrayList集合中</p><p><strong>代码实现</strong>  </p><p>　　递归思路(T(N)=O(N),S(N)=O(1))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(listNode.next!=<span class="keyword">null</span>)&#123;<span class="comment">//如果当前结点及它的下一结点都不为空，先从尾到头把它后面的链表加入ArrayList集合</span></span><br><span class="line">                   list=printListFromTailToHead(listNode.next);</span><br><span class="line">               &#125;</span><br><span class="line">               list.add(listNode.val);<span class="comment">//将当前结点加入ArrayList集合</span></span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> list;<span class="comment">//返回ArrayList集合</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　头插法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//先将所有结点的值按顺序加入ArrayList集合</span></span><br><span class="line">            list.add(<span class="number">0</span> , listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　利用Collections类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//先将所有结点的值按顺序加入ArrayList集合</span></span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Collections.reverse(list);<span class="comment">//使用Collections的reverse方法，直接将list反转</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　利用栈:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">import</span> java.util.Stack;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//所有结点入栈</span></span><br><span class="line">               s.push(listNode.val);</span><br><span class="line">               listNode = listNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(!s.isEmpty())&#123;<span class="comment">//所有结点出栈，并加入ArrayList集合</span></span><br><span class="line">               list.add(s.pop());</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　自实现：</p><div class="spoiler collapsed"><div class="spoiler-title">自实现</div><div class="spoiler-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建ArrayList集合</span></span><br><span class="line">           <span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;<span class="comment">//如果插入结点不为空执行方法，否则直接返回</span></span><br><span class="line">               ListNode newHead = <span class="keyword">this</span>.reverse(listNode);<span class="comment">//调用反转方法返回反转后的新表头</span></span><br><span class="line">               <span class="keyword">while</span>(newHead != <span class="keyword">null</span>)&#123;<span class="comment">//将反转后的链表逐个加入ArrayList集合</span></span><br><span class="line">                   list.add(newHead.val);</span><br><span class="line">                   newHead = newHead.next;</span><br><span class="line">               &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           <span class="keyword">return</span> list;<span class="comment">//返回ArrayList集合</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//反转方法源自上面一题的非递归方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">           ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">           ListNode next = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">               next = listNode.next;</span><br><span class="line">               listNode.next = node.next;</span><br><span class="line">               node.next = listNode;</span><br><span class="line">               listNode = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> node.next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></div><br><h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a><em>链表中倒数第k个结点</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzUyOWQzYWU1YTQwNzQ5Mjk5NGFkMmEyNDY1MTgxNDhhP3RwSWQ9MTMmdHFJZD0xMTE2NyZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_22<i class="fa fa-external-link"></i></span>  </p><p><strong>题目描述</strong><br><img src="http://q103n68fw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer_22.jpg" alt="剑指offer-22">  </p><p><strong>解题思路</strong><br>　　分析：链表不像数组能通过索引直接确定位置，所以难点在于对于一个结点，该如何明确它是倒数第几个。<br>　　思路：维护两个指针，,第一个指针先走k-1步，第二个指针保持不动；从第k步开始，两个指针一起向后移动。当走在前面的指针移动到链表末尾时，后面指针所指向的结点即为目标结点。<br><img src="http://q103n68fw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer_22.1.jpg" alt="剑指offer_22"><br>　　此外还可以用<br>　　　　A. 利用ArrayList集合的索引实现。<br>　　　　B. 利用栈实现;<br>　　只不过这两种方法空间复杂度会比较高，所以不推荐。 </p><p><strong>代码实现</strong><br>　　双指针(T(N)=O(N),S(N)=O(1))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           ListNode target , pAhead;<span class="comment">//维护两个指针</span></span><br><span class="line">           target = pAhead = head;<span class="comment">//双双指向链表开头</span></span><br><span class="line">           <span class="keyword">int</span> counter = <span class="number">0</span>;<span class="comment">//用来记录pAhead移动步数</span></span><br><span class="line">           <span class="keyword">for</span>(;pAhead != <span class="keyword">null</span>; counter++)&#123;<span class="comment">//pAhead指针开始移动到链表尾部</span></span><br><span class="line">               <span class="keyword">if</span>(counter &gt;= k)&#123;<span class="comment">//如果pAhead指针已经移动了k步，则target开始移动</span></span><br><span class="line">                   target = target.next;</span><br><span class="line">               &#125;</span><br><span class="line">               pAhead = pAhead.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//移动步数counter遍历完成时是等于链表长度的，如果移动步数小于k，说明k超过链表长度</span></span><br><span class="line">           <span class="keyword">return</span> counter &lt; k? <span class="keyword">null</span>: target;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　集合法(T(N)=O(N),S(N)=O(N))：将所有结点加入ArrayList集合，倒数第k个即为正数第n-k+1个(n为结点数),利用get方法即可求出</p><div class="spoiler collapsed"><div class="spoiler-title">集合法</div><div class="spoiler-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;<span class="comment">//结点全加入集合里</span></span><br><span class="line">               list.add(head);</span><br><span class="line">               head = head.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(k &gt; list.size() || k &lt;= <span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//k大于结点数或者为非正数，返回null</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">return</span> list.get(list.size() - k);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></div><p>　　栈方法(T(N)=O(N),S(N)=O(N))：利用栈的先进后出，先将所有结点加入栈，最后再从栈弹出k个元素，弹出的第k个即为倒数第k个</p><div class="spoiler collapsed"><div class="spoiler-title">栈方法</div><div class="spoiler-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">           Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;<span class="comment">//所有结点入栈</span></span><br><span class="line">               stack.push(head);</span><br><span class="line">               head = head.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(k &gt; stack.size() || k &lt;= <span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//k大于结点数或者为非正数，返回null</span></span><br><span class="line">           <span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;<span class="comment">//先弹出k-1个元素</span></span><br><span class="line">               stack.pop();</span><br><span class="line">               k--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> stack.pop();<span class="comment">//返回倒数第k个</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></div><br><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><em>合并两个排序的链表</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2Q4YjZiNDM1OGY3NzQyOTRhODlkZTJhNmFjNGQ5MzM3P3RwSWQ9MTMmdHFJZD0xMTE2OSZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_25<i class="fa fa-external-link"></i></span></p><p>　　<strong>题目描述</strong><br><img src="http://q103n68fw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer_25.jpg" alt="剑指offer-25"> </p><p>　　<strong>解题思路</strong><br>　　递归思路:当两个结点中，有一个为空，返回不为空的结点。都不为空时，继续将较小结点的后一结点和较大结点进行合并，直到其中一方为空。<br>　　非递归思路:当两个结点中，有一个为空，返回不为空的结点。都不为空时,设立一个头结点,每次比较将两个结点较小的接入头结点后面，直到一方为空。  </p><p>　　<strong>代码实现</strong><br>　　递归思路：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)<span class="comment">//如果有一个结点为空，就返回另一个结点 </span></span><br><span class="line">               <span class="keyword">return</span> list1 == <span class="keyword">null</span>? list2 : list1;</span><br><span class="line">           <span class="keyword">if</span>(list1.val &gt; list2.val)&#123;<span class="comment">//list2较小时</span></span><br><span class="line">               list2.next = Merge(list1, list2.next);<span class="comment">//将以list1和list2下一结点开头的两个链表进行合并，并接入到list2后面。</span></span><br><span class="line">               <span class="keyword">return</span> list2;<span class="comment">//返回合并后的链表list2</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则，list1较小时</span></span><br><span class="line">               list1.next = Merge(list1.next, list2);<span class="comment">//将以list2和list1下一结点开头的两个链表进行合并，并接入到list1后面。</span></span><br><span class="line">               <span class="keyword">return</span> list1;<span class="comment">//返回合并后的链表list1</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　非递归:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(list1 == <span class="keyword">null</span> || list2 == <span class="keyword">null</span>)<span class="comment">//如果有一个结点为空，就返回另一个结点 </span></span><br><span class="line">               <span class="keyword">return</span> list1 == <span class="keyword">null</span>? list2 : list1;</span><br><span class="line"></span><br><span class="line">           ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//先设一个头结点作为当前结点</span></span><br><span class="line">           ListNode curNode = head;<span class="comment">//设置当前结点指针</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;&amp;list2!=<span class="keyword">null</span>)&#123;<span class="comment">//当有一个结点为空时跳出循环</span></span><br><span class="line">               <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;<span class="comment">//list1较小时</span></span><br><span class="line">          curNode.next = list1;<span class="comment">//将list1接入head链表后</span></span><br><span class="line">           curNode = curNode.next;<span class="comment">//当前结点向后移动</span></span><br><span class="line">           list1 = list1.next;<span class="comment">//较小结点list1向后移动</span></span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;<span class="comment">//list2较小时</span></span><br><span class="line">           curNode.next = list2;<span class="comment">//将list2接入head链表后</span></span><br><span class="line">           curNode = curNode.next;<span class="comment">//当前结点向后移动</span></span><br><span class="line">           list2 = list2.next;<span class="comment">//较小结点list1向后移动</span></span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//把未结束的链表连接到合并后的链表尾部</span></span><br><span class="line">           <span class="keyword">if</span>(list1!=<span class="keyword">null</span>)&#123;<span class="comment">//若是list1不为空就把list1接入链表尾部</span></span><br><span class="line">           curNode.next=list1;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(list2!=<span class="keyword">null</span>)&#123;<span class="comment">//若是list2不为空就把list2接入链表尾部</span></span><br><span class="line">           curNode.next=list2;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> head.next;<span class="comment">//返回合并后链表的第一个结点</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a><em>两个链表的第一个公共结点</em></h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzZhYjFkOWEyOWU4ODQ1MDY4NTA5OWQ0NWM5ZTMxZTQ2P3RwSWQ9MTMmdHFJZD0xMTE4OSZ0UGFnZT0xJnJwPTEmcnU9L3RhL2NvZGluZy1pbnRlcnZpZXdzJnFydT0vdGEvY29kaW5nLWludGVydmlld3MvcXVlc3Rpb24tcmFua2luZw==" title="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer_52<i class="fa fa-external-link"></i></span></p><p><strong>题目描述</strong><br><img src="http://q103n68fw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer_52.jpg" alt="剑指offer-52">  </p><p><strong>解题思路</strong><br>　　对于上图。我们设链表1的长度为 a + c，链表2的长度为 b + c，其中c为尾部公共部分长度<br>　　思路有以下几种：<br>　　A:利用哈希表:先将一个链表加入哈希表，在遍历另一个链表时判断哈希表中有无对应的key，即可求得第一个公共结点<br>　　B:利用长度差：求出两个链表长度差值即b-a，再让位于较长的链表的结点指针先走b-a步，再让另一个出发，之后每走一步两者就进行比较一次，若是相等，指向的则为第一个公共结点<br>　　C:利用双指针循环遍历：当访问链表 A 的指针访问到链表尾部时，令它从链表B的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。  </p><p><strong>代码实现</strong></p><p>　　哈希表：此方法实现逻辑简单，但是数据量庞大时效率不如方法B，空间复杂度也比其他方法高，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">           HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//建立HashSet集合</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(pHead1 != <span class="keyword">null</span>)&#123;<span class="comment">//将链表1的结点加入哈希表</span></span><br><span class="line">               set.add(pHead1);</span><br><span class="line">               pHead1 = pHead1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(pHead2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(set.contains(pHead2))&#123;<span class="comment">//判断当前链表2的结点在哈希表是否存在</span></span><br><span class="line">                   <span class="keyword">return</span> pHead2;<span class="comment">//存在则说明是公共结点</span></span><br><span class="line">               &#125;</span><br><span class="line">               pHead2 = pHead2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//哈希表没有存储pHead2的结点,返回空</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　双指针循环遍历：双指针循环遍历相当于是两个指针同时出发直到它们在同一结点相遇，此结点即为第一个公共结点。此方法代码量简短，但是如果没有公共结点时会陷入死循环。此方法在数据量庞大时效率极为低效，基本不考虑使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = pHead1 , node2 = pHead2;<span class="comment">//定义两个用来遍历链表的指针node1，node2</span></span><br><span class="line">         <span class="keyword">while</span>(node1 != node2)&#123;<span class="comment">//当两指针指向的结点相等时才跳出循环</span></span><br><span class="line">             node1 = node1 == <span class="keyword">null</span>? pHead1 : node1.next;<span class="comment">//否则若node1到达链表末尾时，重新出发进行遍历</span></span><br><span class="line">             node2 = node2 == <span class="keyword">null</span>? pHead2 : node2.next;<span class="comment">//若node2到达链表末尾时，也重新出发进行遍历</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;<span class="comment">//跳出循环时的node1和node2指向第一个公共结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　利用长度差：利用长度差来实现同时到达公共结点，此方法适用于庞大数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">           ListNode current1 = pHead1;<span class="comment">// 链表1</span></span><br><span class="line">           ListNode current2 = pHead2;<span class="comment">// 链表2</span></span><br><span class="line">           <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> length1 = getLength(current1);</span><br><span class="line">           <span class="keyword">int</span> length2 = getLength(current2);</span><br><span class="line">           <span class="comment">// 两连表的长度差</span></span><br><span class="line">            </span><br><span class="line">           <span class="comment">// 如果链表1的长度大于链表2的长度</span></span><br><span class="line">           <span class="keyword">if</span> (length1 &gt;= length2) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = length1 - length2;</span><br><span class="line">               <span class="comment">// 先遍历链表1，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   current1 = current1.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果链表2的长度大于链表1的长度</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (length1 &lt; length2) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = length2 - length1;</span><br><span class="line">               <span class="comment">// 先遍历链表1，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   current2 = current2.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//开始齐头并进，直到找到第一个公共结点</span></span><br><span class="line">           <span class="keyword">while</span>(current1!=current2)&#123;</span><br><span class="line">               current1=current1.next;</span><br><span class="line">               current2=current2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> current1;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 求指定链表的长度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">           ListNode current = pHead;</span><br><span class="line">           <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">               length++;</span><br><span class="line">               current = current.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> length;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　优化：长度相同且有公共结点，第一次就会遍历就能判断出来，不必执行接下来的操作可以直接返回。长度不相同则记录两个链表长度，再执行接下来操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> length1 = <span class="number">0</span>, length2 = <span class="number">0</span>;</span><br><span class="line">           ListNode node1 = pHead1 , node2 = pHead2;<span class="comment">//定义两个用来遍历链表的指针node1，node2</span></span><br><span class="line">           <span class="keyword">while</span>(node1 != node2 &amp;&amp; (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>))&#123;<span class="comment">//当两指针都为null时才结束循环</span></span><br><span class="line">   </span><br><span class="line">               <span class="keyword">if</span>(node1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   node1 = node1.next;</span><br><span class="line">                   length1++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   node2 = node2.next;</span><br><span class="line">                   length2++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//进行第一次遍历时两指针相等说明链表长度相同，该点为第一个公共结点，直接返回</span></span><br><span class="line">               <span class="keyword">if</span>(node1 == node2 &amp;&amp; (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>))   </span><br><span class="line">                   <span class="keyword">return</span> node1;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 两连表的长度差</span></span><br><span class="line">           <span class="keyword">if</span> (length1 &gt; length2) &#123;<span class="comment">// 如果链表1的长度大于链表2的长度</span></span><br><span class="line">               <span class="keyword">int</span> len = length1 - length2;</span><br><span class="line">               <span class="comment">// 先遍历链表1，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   pHead1 = pHead1.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (length1 &lt; length2) &#123;<span class="comment">// 如果链表2的长度大于链表1的长度</span></span><br><span class="line">               <span class="keyword">int</span> len = length2 - length1;</span><br><span class="line">               <span class="comment">// 先遍历链表2，遍历的长度就是两链表的长度差</span></span><br><span class="line">               <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   pHead2 = pHead2.next;</span><br><span class="line">                   len--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//开始齐头并进，直到找到第一个公共结点</span></span><br><span class="line">           <span class="keyword">while</span>(pHead1!=pHead2)&#123;</span><br><span class="line">               pHead1=pHead1.next;</span><br><span class="line">               pHead2=pHead2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> pHead1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h2 id="递归与循环"><a href="#递归与循环" class="headerlink" title="递归与循环"></a>递归与循环</h2><h2 id="查找与排序"><a href="#查找与排序" class="headerlink" title="查找与排序"></a>查找与排序</h2><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h2 id="动态规划与贪心算法"><a href="#动态规划与贪心算法" class="headerlink" title="动态规划与贪心算法"></a>动态规划与贪心算法</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文将对剑指offer的题型进行整理，包括解题思路和代码实现。分类依据则是基于题目的侧重考点进行分类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://chiayhonl.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://chiayhonl.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客系列(二)：主题美化篇</title>
    <link href="http://chiayhonl.top/archives/92d97ddb.html"/>
    <id>http://chiayhonl.top/archives/92d97ddb.html</id>
    <published>2019-11-11T10:29:08.000Z</published>
    <updated>2019-11-15T16:45:52.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本篇主要介绍博客主题的选择与配置，以及如何进行美化。</p><a id="more"></a><br><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>　　Hexo默认的主题是landscape，推荐以下主题：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0" title="https://github.com/theme-next/hexo-theme-next">Next<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdHRlbi9oZXhvLXRoZW1lLXlpbGlh" title="https://github.com/litten/hexo-theme-yilia">Yilia<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JsaW5rZm94L2hleG8tdGhlbWUtbWF0ZXJ5" title="https://github.com/blinkfox/hexo-theme-matery">matery<i class="fa fa-external-link"></i></span></p></li></ul><p>　　更多主题可在<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=" title="https://hexo.io/themes/">Themes<i class="fa fa-external-link"></i></span>商店选择。不同的主题配置可能有所不同。</p>   <br><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><p>   <strong>第一步：下载主题</strong></p><p>　　进入你的博客文件夹(Hexo),打开Git Bash输入以下命令，等待下载完成。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span>.git themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>　　或者进入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0L3JlbGVhc2Vz" title="https://github.com/theme-next/hexo-theme-next/releases">NexT发布页<i class="fa fa-external-link"></i></span>选择版本下载。</p><p>   <strong>第二步：选择主题</strong></p><p>　　下载完成后，在themes目录下会有next文件夹，这就是我们要的next主题。然后在主目录下找到站点配置文件_config.yml 中的theme字段，更改为主题文件夹的名称：</p><figure class="highlight yaml"><figcaption><span>/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释掉landscape主题,加入next主题</span></span><br><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>　　运行<code>hexo clean &amp; hexo g &amp; hexo s</code>重启服务器即可查看效果<br>　　PS：Next 默认主题风格为 Muse，可配置文件中修改<code>scheme</code>字段以选择自己喜欢的主题风格：</p><br><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>　　在更换主题后，需要进行相应的配置，完成对博客的优化。  </p><h3 id="博客基础信息"><a href="#博客基础信息" class="headerlink" title="博客基础信息"></a>博客基础信息</h3><p>　　修改站点配置文件</p><figure class="highlight yaml"><figcaption><span>/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Chiayhon's</span> <span class="string">Blog</span> <span class="comment"># 博客名</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">lazy</span> <span class="string">bee</span> <span class="comment"># 博客描述</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'！间歇性踌躇满志,持续性混吃等死'</span> <span class="comment"># 个人描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Chiayhon</span> <span class="comment">#名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">'Asia/Shanghai'</span> <span class="comment">#时区</span></span><br></pre></td></tr></table></figure><h3 id="显示文章摘要"><a href="#显示文章摘要" class="headerlink" title="显示文章摘要"></a>显示文章摘要</h3><p>　　默认的主题配置会显示每一篇文章的全文，如果想要只显示部分，可以在主题配置文件中做出如下更改</p><figure class="highlight yaml"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 开启自动摘要提取</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure><h3 id="修改底部信息"><a href="#修改底部信息" class="headerlink" title="修改底部信息"></a>修改底部信息</h3><p>　　在主题配置文件中修改网站页脚信息：</p><figure class="highlight yaml"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span>  <span class="comment"># 底部信息区</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2019</span>  <span class="comment"># 建站时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span>   <span class="comment"># 图标名称</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>   <span class="comment"># 开启动画</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#ff0000"</span>   <span class="comment"># 图标颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示由 Hexo 强力驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏 Hexo 版本号</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示所用的主题名称</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏主题版本号</span></span><br></pre></td></tr></table></figure><h3 id="修改博客logo"><a href="#修改博客logo" class="headerlink" title="修改博客logo"></a>修改博客logo</h3><p>　　将自定义的logo放置在images目录下，然后设置文件路径和文件名即可</p><figure class="highlight yaml"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/logo.jpg</span> <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/logo.jpg</span> <span class="comment"># 大图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/logo.jpg</span> <span class="comment"># 苹果图标</span></span><br></pre></td></tr></table></figure><br><h3 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h3><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><p>　　这里大致进行一些简单的美化：</p><ul><li><p>设置主题语言</p></li><li><p>设置动态背景</p></li><li><p>上传头像,并设置头像旋转效果</p></li><li><p>设置个人社交图标链接</p></li><li><p>设置RSS</p></li><li><p>设置看板娘</p></li><li><p>代码折叠功能</p></li><li><p>Url持久化</p></li></ul><h3 id="设置看板娘"><a href="#设置看板娘" class="headerlink" title="设置看板娘"></a>设置看板娘</h3><p>　　看板娘github地址： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk" title="https://github.com/EYHN/hexo-helper-live2d">https://github.com/EYHN/hexo-helper-live2d<i class="fa fa-external-link"></i></span>  </p><p>　　第一步:安装模块  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-helper-live2d</span></span><br></pre></td></tr></table></figure><p>　　第二步:在站点配置文件<code>_config.yml</code>或主题配置文件<code>_config.yml</code>中新增如下内容：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span> <span class="comment"># 手机中是否展示</span></span><br></pre></td></tr></table></figure><p>　　配置完成重新部署即可。  </p><p>　　进阶:如果有兴趣进一步设置，可参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZlbmpvZXpoYW5nL2xpdmUyZC13aWRnZXQ=" title="https://github.com/stevenjoezhang/live2d-widget">大神<i class="fa fa-external-link"></i></span>的项目,效果如本站的看板娘</p><h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><p>　　安装spoiler插件:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-sliding-spoiler <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>　　折叠语法：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">spoiler</span> 标题 %&#125;</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">内容</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endspoiler</span> %&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Url持久化"><a href="#Url持久化" class="headerlink" title="Url持久化"></a>Url持久化</h3><p>　　当我们发表一篇博文并部署到服务器上时，会发现hexo默认生成的文章地址是【网站名称／年／月／日／文章名称】即类似于 <span class="exturl" data-url="aHR0cDovL3d3dy5jaGlheWhvbmwudG9wLzIwMTkvMTEvMTEvSGV4by1Db25maWcuaHRtbA==" title="http://www.chiayhonl.top/2019/11/11/Hexo-Config.html">http://www.chiayhonl.top/2019/11/11/Hexo-Config.html<i class="fa fa-external-link"></i></span><br>　　这种链接对搜索爬虫是很不友好的，它的url结构超过了三层，太深了，会影响网站被搜索引擎爬虫的抓取，不利于内容被收录。<br>　　所以我们有两种方法解决这个问题： </p><p>　　<strong>A</strong>：打开_config.yml配置文件，找到permalink</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释掉原来的permalink，改为下面这样</span></span><br><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/ </span></span><br><span class="line"><span class="attr">permalink:</span>   <span class="string">/articles/:title.html</span></span><br></pre></td></tr></table></figure><p>　　上面这种方式是去掉了年月日，保持网站最多三层。  </p><p>　　<strong>B</strong>(推荐):<br>　　<strong>第一步：安装 hexo-abbrlink</strong>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-abbrlink <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>　　<strong>第二步：配置_config.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将之前的注释掉,改成下面的</span></span><br><span class="line"><span class="comment"># permalink: :title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>　　配置完成后只需要<code>hexo g &amp; hexo d</code>就可以发布啦！<br>　　效果如下，怎么样，是不是很赞呢？</p><p><img src="http://q102vhzcl.bkt.clouddn.com/2-%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96_URL%E6%8C%81%E4%B9%85%E5%8C%96.jpg" alt="图片加载失败"></p><p>　　但是要注意，在进行上面操作后，图片的加载路径也要进行相应的修改，或者使用外链(推荐把图床放在七牛云)。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本篇主要介绍博客主题的选择与配置，以及如何进行美化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客系列(一):搭建部署篇</title>
    <link href="http://chiayhonl.top/archives/aedfb7c1.html"/>
    <id>http://chiayhonl.top/archives/aedfb7c1.html</id>
    <published>2019-11-10T12:00:00.000Z</published>
    <updated>2019-11-15T16:45:53.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本篇介绍了利用Hexo框架建立博客及部署上线的过程，<br><br></p><a id="more"></a><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><p>　　搭建个人博客=域名(外网可访问的地址)+外网服务器(外网存储文件图片的地方)+解析(本地与服务器做映射)</p><p>　　搭建流程大概分为:</p><p>　　1. 下载<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0LXNjbS5jb20vZG93bmxvYWQv" title="https://www.git-scm.com/download/">git<i class="fa fa-external-link"></i></span>,下载<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL2N1cnJlbnQv" title="https://nodejs.org/en/download/current/">node.js<i class="fa fa-external-link"></i></span>,搭建<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv" title="https://hexo.io/zh-cn/docs/">Hexo<i class="fa fa-external-link"></i></span></p><p>　　2. <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">GitHub<i class="fa fa-external-link"></i></span>仓库注册与部署</p><p>　　3. 域名购买</p><p>　　4. 部署上线</p><h3 id="环境的下载与安装"><a href="#环境的下载与安装" class="headerlink" title="环境的下载与安装"></a><em>环境的下载与安装</em></h3><p><strong>第一步：首先先下载git和 node.js，具体安装流程不在叙述：</strong><br>　　下载并安装git：<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZC93aW4=" title="https://git-scm.com/download/win">https://git-scm.com/download/win<i class="fa fa-external-link"></i></span><br>　　下载并安装node.js ；<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkL2N1cnJlbnQv" title="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/<i class="fa fa-external-link"></i></span>    </p><p><strong>第二步：先在E盘(自行选择）中建立一个文件夹用于存储本地文件，文件夹名字自己定</strong></p><p><strong>第三步：进入文件夹目录，打开命令行工具，依次输入以下命令：</strong></p><ul><li>安装Hexo : -g 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。  </li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><ul><li>初始化Hexo: </li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure><p>　　此时，指定文件夹的目录大致如下：</p><pre><code>.  ├── node_modules       //依赖安装目录  ├── scaffolds          //模板文件夹，新建的文章将会从此目录下的文件中继承格式  |   ├── draft.md         //草稿模板  |   ├── page.md          //页面模板  |   └── post.md          //文章模板  ├── source             //资源文件夹，用于放置图片、数据、文章等资源  |   └── _posts           //文章目录  ├── themes             //主题文件夹  |   └── landscape        //默认主题  ├── .gitignore         //指定不纳入git版本控制的文件  ├── _config.yml        //站点配置文件  ├── db.json              ├── package.json  └── package-lock.json</code></pre><ul><li>启动Hexo服务: 部署到本地</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp; hexo <span class="keyword">generate</span> &amp;  hexo server</span><br></pre></td></tr></table></figure><p>　　执行以上命令之后，hexo就会在public文件夹生成相关html文件，如下图</p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/hexo%E6%90%AD%E5%BB%BA_helloworld.png" alt="相关html文件"></p><p><strong>第四步：访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAw" title="http://localhost:4000">http://localhost:4000<i class="fa fa-external-link"></i></span> 查看这个页面。在命令行窗口按Ctrl+C可退出</strong></p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/hexo%E6%90%AD%E5%BB%BA_hexoServer.png" alt="命令行窗口"></p><p>　　详细内容请参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv" title="https://hexo.io/zh-cn/docs/">官方文档<i class="fa fa-external-link"></i></span>  </p><br><h3 id="服务器的部署"><a href="#服务器的部署" class="headerlink" title="服务器的部署"></a><em>服务器的部署</em></h3><p>　　要稳定地运行博客，则需自行购买服务器。个人要求不高，可借用GitHub的服务器。</p><p><strong>第一步：注册/登录github： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">https://github.com/<i class="fa fa-external-link"></i></span></strong> </p><p>　　PS:注册后建议配置一个<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vZ2l0aHViL2F1dGhlbnRpY2F0aW5nLXRvLWdpdGh1Yi9jb25uZWN0aW5nLXRvLWdpdGh1Yi13aXRoLXNzaA==" title="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">SHH key<i class="fa fa-external-link"></i></span></p><p><strong>第二步：初始化仓库：新建(New)一个仓库。新建仓库名字为：用户名 + .github.io。</strong></p><p><img src="http://q102vhzcl.bkt.clouddn.com/hexo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2_%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt="初始化仓库"></p><p><strong>第三步：仓库新建完成后，复制第一个命令块</strong></p><p><img src="http://q102vhzcl.bkt.clouddn.com/hexo%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA_github%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B.png" alt="命令块"></p><p><strong>第四步：在博客文件夹目录打开Git Bash命令窗口进行粘贴。</strong></p><p><img src="http://q102vhzcl.bkt.clouddn.com/hexo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2_git%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4.png" alt="Bash命令窗口"></p><p><strong>第五步：打开并配置_config.yml中有关deploy的部分，修改如下,注意将<code>name</code>改为你的用户名</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/name/name.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><strong>第六步：在hexo文件夹打开git bash窗口，输入以下命令将代码全部提交到github</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure><br><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a><em>购买域名</em></h3><p>　　本地环境和服务器的配置好后，需要购买一个域名，以便使博客能够通过互联网被访问。</p><p>　　去阿里云购买一个域名 <span class="exturl" data-url="aHR0cDovL3d3dy5hbGl5dW4uY29t" title="http://www.aliyun.com">www.aliyun.com<i class="fa fa-external-link"></i></span> (其他类似腾讯云等等也行)，根据自己经济能力选择域名购买即可</p><p>　　<img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0.png" alt="域名购买"></p><p>　　购买后还要进行一系列的实名验证和备案等操作这里就不在展示了，各位根据购买网站指示自行完成即可</p><br><h3 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a><em>部署上线</em></h3><p><strong>第一步：在购买成功后。找到域名控制台进行(以阿里云为例)</strong></p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="域名控制台"></p><p><strong>第二步： 进行新手引导</strong></p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%901.png" alt="域名解析"></p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%902.png" alt="域名解析"></p><p><strong>第三步：网站解析设置完后，修改记录值</strong></p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%903.png" alt="修改记录值"></p><p><strong>第四步；打开命令行窗口进行ping操作，查看是否能与服务器通信</strong></p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_ping.png" alt="ping"></p><br><p>　　此外还有两个地方要修改：</p><p>A、 source文件的CNAME记录：</p><p>　　创建方式:右键新建txt文本-&gt;输入你购买的域名 <span class="exturl" data-url="aHR0cDovL3d3dy5jaGlheWhvbmwudG9w" title="http://www.chiayhonl.top">www.chiayhonl.top<i class="fa fa-external-link"></i></span> -&gt; 保存关闭 -&gt; 去掉.txt后缀</p><p><img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_cname%E8%AE%B0%E5%BD%951.png" alt="CNAME记录"></p><p>B、 服务器绑定域名：</p><p>　　找到仓库的setting页面</p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.png" alt="setting"></p><p>　　拉倒最下面</p><p>   <img src="http://q102vhzcl.bkt.clouddn.com/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90_%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D2.png" alt="setting"></p><p>　　到这博客基本框架已搭建完毕,输入自己购买的域名如： <span class="exturl" data-url="aHR0cDovL3d3dy5jaGlheWhvbmwudG9w" title="http://www.chiayhonl.top">www.chiayhonl.top<i class="fa fa-external-link"></i></span> 便会显示出自己博客的首页。</p><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><ul><li><strong>4000 端口已被其他应用占用</strong><br>解决方式：添加 <code>-p</code>/<code>--port</code> 参数来设置 Web 服务监听的端口号，如 <code>hexo s -p 8000</code></li></ul><br><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本篇介绍了利用Hexo框架建立博客及部署上线的过程，&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://chiayhonl.top/tags/Hexo/"/>
    
      <category term="安装教程" scheme="http://chiayhonl.top/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
